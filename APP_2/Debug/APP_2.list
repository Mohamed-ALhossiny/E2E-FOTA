
APP_2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08012800  08012800  00002800  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001f1c  08012910  08012910  00002910  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  0801482c  0801482c  000100d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  0801482c  0801482c  000100d0  2**0
                  CONTENTS
  4 .ARM          00000000  0801482c  0801482c  000100d0  2**0
                  CONTENTS
  5 .preinit_array 00000000  0801482c  0801482c  000100d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0801482c  0801482c  0000482c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08014830  08014830  00004830  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000000d0  20000000  08014834  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000064  200000d0  08014904  000100d0  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20000134  08014904  00010134  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  000100d0  2**0
                  CONTENTS, READONLY
 12 .debug_info   000031b7  00000000  00000000  000100f9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00000e75  00000000  00000000  000132b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000410  00000000  00000000  00014128  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000348  00000000  00000000  00014538  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00004f3c  00000000  00000000  00014880  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   000019b9  00000000  00000000  000197bc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00038a7b  00000000  00000000  0001b175  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  00053bf0  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000e54  00000000  00000000  00053c40  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08012910 <__do_global_dtors_aux>:
 8012910:	b510      	push	{r4, lr}
 8012912:	4c05      	ldr	r4, [pc, #20]	; (8012928 <__do_global_dtors_aux+0x18>)
 8012914:	7823      	ldrb	r3, [r4, #0]
 8012916:	b933      	cbnz	r3, 8012926 <__do_global_dtors_aux+0x16>
 8012918:	4b04      	ldr	r3, [pc, #16]	; (801292c <__do_global_dtors_aux+0x1c>)
 801291a:	b113      	cbz	r3, 8012922 <__do_global_dtors_aux+0x12>
 801291c:	4804      	ldr	r0, [pc, #16]	; (8012930 <__do_global_dtors_aux+0x20>)
 801291e:	f3af 8000 	nop.w
 8012922:	2301      	movs	r3, #1
 8012924:	7023      	strb	r3, [r4, #0]
 8012926:	bd10      	pop	{r4, pc}
 8012928:	200000d0 	.word	0x200000d0
 801292c:	00000000 	.word	0x00000000
 8012930:	08014814 	.word	0x08014814

08012934 <frame_dummy>:
 8012934:	b508      	push	{r3, lr}
 8012936:	4b03      	ldr	r3, [pc, #12]	; (8012944 <frame_dummy+0x10>)
 8012938:	b11b      	cbz	r3, 8012942 <frame_dummy+0xe>
 801293a:	4903      	ldr	r1, [pc, #12]	; (8012948 <frame_dummy+0x14>)
 801293c:	4803      	ldr	r0, [pc, #12]	; (801294c <frame_dummy+0x18>)
 801293e:	f3af 8000 	nop.w
 8012942:	bd08      	pop	{r3, pc}
 8012944:	00000000 	.word	0x00000000
 8012948:	200000d4 	.word	0x200000d4
 801294c:	08014814 	.word	0x08014814

08012950 <__aeabi_drsub>:
 8012950:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8012954:	e002      	b.n	801295c <__adddf3>
 8012956:	bf00      	nop

08012958 <__aeabi_dsub>:
 8012958:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0801295c <__adddf3>:
 801295c:	b530      	push	{r4, r5, lr}
 801295e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8012962:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8012966:	ea94 0f05 	teq	r4, r5
 801296a:	bf08      	it	eq
 801296c:	ea90 0f02 	teqeq	r0, r2
 8012970:	bf1f      	itttt	ne
 8012972:	ea54 0c00 	orrsne.w	ip, r4, r0
 8012976:	ea55 0c02 	orrsne.w	ip, r5, r2
 801297a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 801297e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8012982:	f000 80e2 	beq.w	8012b4a <__adddf3+0x1ee>
 8012986:	ea4f 5454 	mov.w	r4, r4, lsr #21
 801298a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 801298e:	bfb8      	it	lt
 8012990:	426d      	neglt	r5, r5
 8012992:	dd0c      	ble.n	80129ae <__adddf3+0x52>
 8012994:	442c      	add	r4, r5
 8012996:	ea80 0202 	eor.w	r2, r0, r2
 801299a:	ea81 0303 	eor.w	r3, r1, r3
 801299e:	ea82 0000 	eor.w	r0, r2, r0
 80129a2:	ea83 0101 	eor.w	r1, r3, r1
 80129a6:	ea80 0202 	eor.w	r2, r0, r2
 80129aa:	ea81 0303 	eor.w	r3, r1, r3
 80129ae:	2d36      	cmp	r5, #54	; 0x36
 80129b0:	bf88      	it	hi
 80129b2:	bd30      	pophi	{r4, r5, pc}
 80129b4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80129b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80129bc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80129c0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80129c4:	d002      	beq.n	80129cc <__adddf3+0x70>
 80129c6:	4240      	negs	r0, r0
 80129c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80129cc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80129d0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80129d4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80129d8:	d002      	beq.n	80129e0 <__adddf3+0x84>
 80129da:	4252      	negs	r2, r2
 80129dc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80129e0:	ea94 0f05 	teq	r4, r5
 80129e4:	f000 80a7 	beq.w	8012b36 <__adddf3+0x1da>
 80129e8:	f1a4 0401 	sub.w	r4, r4, #1
 80129ec:	f1d5 0e20 	rsbs	lr, r5, #32
 80129f0:	db0d      	blt.n	8012a0e <__adddf3+0xb2>
 80129f2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80129f6:	fa22 f205 	lsr.w	r2, r2, r5
 80129fa:	1880      	adds	r0, r0, r2
 80129fc:	f141 0100 	adc.w	r1, r1, #0
 8012a00:	fa03 f20e 	lsl.w	r2, r3, lr
 8012a04:	1880      	adds	r0, r0, r2
 8012a06:	fa43 f305 	asr.w	r3, r3, r5
 8012a0a:	4159      	adcs	r1, r3
 8012a0c:	e00e      	b.n	8012a2c <__adddf3+0xd0>
 8012a0e:	f1a5 0520 	sub.w	r5, r5, #32
 8012a12:	f10e 0e20 	add.w	lr, lr, #32
 8012a16:	2a01      	cmp	r2, #1
 8012a18:	fa03 fc0e 	lsl.w	ip, r3, lr
 8012a1c:	bf28      	it	cs
 8012a1e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8012a22:	fa43 f305 	asr.w	r3, r3, r5
 8012a26:	18c0      	adds	r0, r0, r3
 8012a28:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8012a2c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8012a30:	d507      	bpl.n	8012a42 <__adddf3+0xe6>
 8012a32:	f04f 0e00 	mov.w	lr, #0
 8012a36:	f1dc 0c00 	rsbs	ip, ip, #0
 8012a3a:	eb7e 0000 	sbcs.w	r0, lr, r0
 8012a3e:	eb6e 0101 	sbc.w	r1, lr, r1
 8012a42:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8012a46:	d31b      	bcc.n	8012a80 <__adddf3+0x124>
 8012a48:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8012a4c:	d30c      	bcc.n	8012a68 <__adddf3+0x10c>
 8012a4e:	0849      	lsrs	r1, r1, #1
 8012a50:	ea5f 0030 	movs.w	r0, r0, rrx
 8012a54:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8012a58:	f104 0401 	add.w	r4, r4, #1
 8012a5c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8012a60:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8012a64:	f080 809a 	bcs.w	8012b9c <__adddf3+0x240>
 8012a68:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8012a6c:	bf08      	it	eq
 8012a6e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8012a72:	f150 0000 	adcs.w	r0, r0, #0
 8012a76:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8012a7a:	ea41 0105 	orr.w	r1, r1, r5
 8012a7e:	bd30      	pop	{r4, r5, pc}
 8012a80:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8012a84:	4140      	adcs	r0, r0
 8012a86:	eb41 0101 	adc.w	r1, r1, r1
 8012a8a:	3c01      	subs	r4, #1
 8012a8c:	bf28      	it	cs
 8012a8e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8012a92:	d2e9      	bcs.n	8012a68 <__adddf3+0x10c>
 8012a94:	f091 0f00 	teq	r1, #0
 8012a98:	bf04      	itt	eq
 8012a9a:	4601      	moveq	r1, r0
 8012a9c:	2000      	moveq	r0, #0
 8012a9e:	fab1 f381 	clz	r3, r1
 8012aa2:	bf08      	it	eq
 8012aa4:	3320      	addeq	r3, #32
 8012aa6:	f1a3 030b 	sub.w	r3, r3, #11
 8012aaa:	f1b3 0220 	subs.w	r2, r3, #32
 8012aae:	da0c      	bge.n	8012aca <__adddf3+0x16e>
 8012ab0:	320c      	adds	r2, #12
 8012ab2:	dd08      	ble.n	8012ac6 <__adddf3+0x16a>
 8012ab4:	f102 0c14 	add.w	ip, r2, #20
 8012ab8:	f1c2 020c 	rsb	r2, r2, #12
 8012abc:	fa01 f00c 	lsl.w	r0, r1, ip
 8012ac0:	fa21 f102 	lsr.w	r1, r1, r2
 8012ac4:	e00c      	b.n	8012ae0 <__adddf3+0x184>
 8012ac6:	f102 0214 	add.w	r2, r2, #20
 8012aca:	bfd8      	it	le
 8012acc:	f1c2 0c20 	rsble	ip, r2, #32
 8012ad0:	fa01 f102 	lsl.w	r1, r1, r2
 8012ad4:	fa20 fc0c 	lsr.w	ip, r0, ip
 8012ad8:	bfdc      	itt	le
 8012ada:	ea41 010c 	orrle.w	r1, r1, ip
 8012ade:	4090      	lslle	r0, r2
 8012ae0:	1ae4      	subs	r4, r4, r3
 8012ae2:	bfa2      	ittt	ge
 8012ae4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8012ae8:	4329      	orrge	r1, r5
 8012aea:	bd30      	popge	{r4, r5, pc}
 8012aec:	ea6f 0404 	mvn.w	r4, r4
 8012af0:	3c1f      	subs	r4, #31
 8012af2:	da1c      	bge.n	8012b2e <__adddf3+0x1d2>
 8012af4:	340c      	adds	r4, #12
 8012af6:	dc0e      	bgt.n	8012b16 <__adddf3+0x1ba>
 8012af8:	f104 0414 	add.w	r4, r4, #20
 8012afc:	f1c4 0220 	rsb	r2, r4, #32
 8012b00:	fa20 f004 	lsr.w	r0, r0, r4
 8012b04:	fa01 f302 	lsl.w	r3, r1, r2
 8012b08:	ea40 0003 	orr.w	r0, r0, r3
 8012b0c:	fa21 f304 	lsr.w	r3, r1, r4
 8012b10:	ea45 0103 	orr.w	r1, r5, r3
 8012b14:	bd30      	pop	{r4, r5, pc}
 8012b16:	f1c4 040c 	rsb	r4, r4, #12
 8012b1a:	f1c4 0220 	rsb	r2, r4, #32
 8012b1e:	fa20 f002 	lsr.w	r0, r0, r2
 8012b22:	fa01 f304 	lsl.w	r3, r1, r4
 8012b26:	ea40 0003 	orr.w	r0, r0, r3
 8012b2a:	4629      	mov	r1, r5
 8012b2c:	bd30      	pop	{r4, r5, pc}
 8012b2e:	fa21 f004 	lsr.w	r0, r1, r4
 8012b32:	4629      	mov	r1, r5
 8012b34:	bd30      	pop	{r4, r5, pc}
 8012b36:	f094 0f00 	teq	r4, #0
 8012b3a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8012b3e:	bf06      	itte	eq
 8012b40:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8012b44:	3401      	addeq	r4, #1
 8012b46:	3d01      	subne	r5, #1
 8012b48:	e74e      	b.n	80129e8 <__adddf3+0x8c>
 8012b4a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8012b4e:	bf18      	it	ne
 8012b50:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8012b54:	d029      	beq.n	8012baa <__adddf3+0x24e>
 8012b56:	ea94 0f05 	teq	r4, r5
 8012b5a:	bf08      	it	eq
 8012b5c:	ea90 0f02 	teqeq	r0, r2
 8012b60:	d005      	beq.n	8012b6e <__adddf3+0x212>
 8012b62:	ea54 0c00 	orrs.w	ip, r4, r0
 8012b66:	bf04      	itt	eq
 8012b68:	4619      	moveq	r1, r3
 8012b6a:	4610      	moveq	r0, r2
 8012b6c:	bd30      	pop	{r4, r5, pc}
 8012b6e:	ea91 0f03 	teq	r1, r3
 8012b72:	bf1e      	ittt	ne
 8012b74:	2100      	movne	r1, #0
 8012b76:	2000      	movne	r0, #0
 8012b78:	bd30      	popne	{r4, r5, pc}
 8012b7a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8012b7e:	d105      	bne.n	8012b8c <__adddf3+0x230>
 8012b80:	0040      	lsls	r0, r0, #1
 8012b82:	4149      	adcs	r1, r1
 8012b84:	bf28      	it	cs
 8012b86:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8012b8a:	bd30      	pop	{r4, r5, pc}
 8012b8c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8012b90:	bf3c      	itt	cc
 8012b92:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8012b96:	bd30      	popcc	{r4, r5, pc}
 8012b98:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8012b9c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8012ba0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8012ba4:	f04f 0000 	mov.w	r0, #0
 8012ba8:	bd30      	pop	{r4, r5, pc}
 8012baa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8012bae:	bf1a      	itte	ne
 8012bb0:	4619      	movne	r1, r3
 8012bb2:	4610      	movne	r0, r2
 8012bb4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8012bb8:	bf1c      	itt	ne
 8012bba:	460b      	movne	r3, r1
 8012bbc:	4602      	movne	r2, r0
 8012bbe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8012bc2:	bf06      	itte	eq
 8012bc4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8012bc8:	ea91 0f03 	teqeq	r1, r3
 8012bcc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8012bd0:	bd30      	pop	{r4, r5, pc}
 8012bd2:	bf00      	nop

08012bd4 <__aeabi_ui2d>:
 8012bd4:	f090 0f00 	teq	r0, #0
 8012bd8:	bf04      	itt	eq
 8012bda:	2100      	moveq	r1, #0
 8012bdc:	4770      	bxeq	lr
 8012bde:	b530      	push	{r4, r5, lr}
 8012be0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8012be4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8012be8:	f04f 0500 	mov.w	r5, #0
 8012bec:	f04f 0100 	mov.w	r1, #0
 8012bf0:	e750      	b.n	8012a94 <__adddf3+0x138>
 8012bf2:	bf00      	nop

08012bf4 <__aeabi_i2d>:
 8012bf4:	f090 0f00 	teq	r0, #0
 8012bf8:	bf04      	itt	eq
 8012bfa:	2100      	moveq	r1, #0
 8012bfc:	4770      	bxeq	lr
 8012bfe:	b530      	push	{r4, r5, lr}
 8012c00:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8012c04:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8012c08:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8012c0c:	bf48      	it	mi
 8012c0e:	4240      	negmi	r0, r0
 8012c10:	f04f 0100 	mov.w	r1, #0
 8012c14:	e73e      	b.n	8012a94 <__adddf3+0x138>
 8012c16:	bf00      	nop

08012c18 <__aeabi_f2d>:
 8012c18:	0042      	lsls	r2, r0, #1
 8012c1a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8012c1e:	ea4f 0131 	mov.w	r1, r1, rrx
 8012c22:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8012c26:	bf1f      	itttt	ne
 8012c28:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8012c2c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8012c30:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8012c34:	4770      	bxne	lr
 8012c36:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8012c3a:	bf08      	it	eq
 8012c3c:	4770      	bxeq	lr
 8012c3e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8012c42:	bf04      	itt	eq
 8012c44:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8012c48:	4770      	bxeq	lr
 8012c4a:	b530      	push	{r4, r5, lr}
 8012c4c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8012c50:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8012c54:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8012c58:	e71c      	b.n	8012a94 <__adddf3+0x138>
 8012c5a:	bf00      	nop

08012c5c <__aeabi_ul2d>:
 8012c5c:	ea50 0201 	orrs.w	r2, r0, r1
 8012c60:	bf08      	it	eq
 8012c62:	4770      	bxeq	lr
 8012c64:	b530      	push	{r4, r5, lr}
 8012c66:	f04f 0500 	mov.w	r5, #0
 8012c6a:	e00a      	b.n	8012c82 <__aeabi_l2d+0x16>

08012c6c <__aeabi_l2d>:
 8012c6c:	ea50 0201 	orrs.w	r2, r0, r1
 8012c70:	bf08      	it	eq
 8012c72:	4770      	bxeq	lr
 8012c74:	b530      	push	{r4, r5, lr}
 8012c76:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8012c7a:	d502      	bpl.n	8012c82 <__aeabi_l2d+0x16>
 8012c7c:	4240      	negs	r0, r0
 8012c7e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8012c82:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8012c86:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8012c8a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8012c8e:	f43f aed8 	beq.w	8012a42 <__adddf3+0xe6>
 8012c92:	f04f 0203 	mov.w	r2, #3
 8012c96:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8012c9a:	bf18      	it	ne
 8012c9c:	3203      	addne	r2, #3
 8012c9e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8012ca2:	bf18      	it	ne
 8012ca4:	3203      	addne	r2, #3
 8012ca6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8012caa:	f1c2 0320 	rsb	r3, r2, #32
 8012cae:	fa00 fc03 	lsl.w	ip, r0, r3
 8012cb2:	fa20 f002 	lsr.w	r0, r0, r2
 8012cb6:	fa01 fe03 	lsl.w	lr, r1, r3
 8012cba:	ea40 000e 	orr.w	r0, r0, lr
 8012cbe:	fa21 f102 	lsr.w	r1, r1, r2
 8012cc2:	4414      	add	r4, r2
 8012cc4:	e6bd      	b.n	8012a42 <__adddf3+0xe6>
 8012cc6:	bf00      	nop

08012cc8 <__aeabi_dmul>:
 8012cc8:	b570      	push	{r4, r5, r6, lr}
 8012cca:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8012cce:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8012cd2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8012cd6:	bf1d      	ittte	ne
 8012cd8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8012cdc:	ea94 0f0c 	teqne	r4, ip
 8012ce0:	ea95 0f0c 	teqne	r5, ip
 8012ce4:	f000 f8de 	bleq	8012ea4 <__aeabi_dmul+0x1dc>
 8012ce8:	442c      	add	r4, r5
 8012cea:	ea81 0603 	eor.w	r6, r1, r3
 8012cee:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8012cf2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8012cf6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8012cfa:	bf18      	it	ne
 8012cfc:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8012d00:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8012d04:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8012d08:	d038      	beq.n	8012d7c <__aeabi_dmul+0xb4>
 8012d0a:	fba0 ce02 	umull	ip, lr, r0, r2
 8012d0e:	f04f 0500 	mov.w	r5, #0
 8012d12:	fbe1 e502 	umlal	lr, r5, r1, r2
 8012d16:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8012d1a:	fbe0 e503 	umlal	lr, r5, r0, r3
 8012d1e:	f04f 0600 	mov.w	r6, #0
 8012d22:	fbe1 5603 	umlal	r5, r6, r1, r3
 8012d26:	f09c 0f00 	teq	ip, #0
 8012d2a:	bf18      	it	ne
 8012d2c:	f04e 0e01 	orrne.w	lr, lr, #1
 8012d30:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8012d34:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8012d38:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8012d3c:	d204      	bcs.n	8012d48 <__aeabi_dmul+0x80>
 8012d3e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8012d42:	416d      	adcs	r5, r5
 8012d44:	eb46 0606 	adc.w	r6, r6, r6
 8012d48:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8012d4c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8012d50:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8012d54:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8012d58:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8012d5c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8012d60:	bf88      	it	hi
 8012d62:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8012d66:	d81e      	bhi.n	8012da6 <__aeabi_dmul+0xde>
 8012d68:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8012d6c:	bf08      	it	eq
 8012d6e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8012d72:	f150 0000 	adcs.w	r0, r0, #0
 8012d76:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8012d7a:	bd70      	pop	{r4, r5, r6, pc}
 8012d7c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8012d80:	ea46 0101 	orr.w	r1, r6, r1
 8012d84:	ea40 0002 	orr.w	r0, r0, r2
 8012d88:	ea81 0103 	eor.w	r1, r1, r3
 8012d8c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8012d90:	bfc2      	ittt	gt
 8012d92:	ebd4 050c 	rsbsgt	r5, r4, ip
 8012d96:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8012d9a:	bd70      	popgt	{r4, r5, r6, pc}
 8012d9c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8012da0:	f04f 0e00 	mov.w	lr, #0
 8012da4:	3c01      	subs	r4, #1
 8012da6:	f300 80ab 	bgt.w	8012f00 <__aeabi_dmul+0x238>
 8012daa:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8012dae:	bfde      	ittt	le
 8012db0:	2000      	movle	r0, #0
 8012db2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8012db6:	bd70      	pople	{r4, r5, r6, pc}
 8012db8:	f1c4 0400 	rsb	r4, r4, #0
 8012dbc:	3c20      	subs	r4, #32
 8012dbe:	da35      	bge.n	8012e2c <__aeabi_dmul+0x164>
 8012dc0:	340c      	adds	r4, #12
 8012dc2:	dc1b      	bgt.n	8012dfc <__aeabi_dmul+0x134>
 8012dc4:	f104 0414 	add.w	r4, r4, #20
 8012dc8:	f1c4 0520 	rsb	r5, r4, #32
 8012dcc:	fa00 f305 	lsl.w	r3, r0, r5
 8012dd0:	fa20 f004 	lsr.w	r0, r0, r4
 8012dd4:	fa01 f205 	lsl.w	r2, r1, r5
 8012dd8:	ea40 0002 	orr.w	r0, r0, r2
 8012ddc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8012de0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8012de4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8012de8:	fa21 f604 	lsr.w	r6, r1, r4
 8012dec:	eb42 0106 	adc.w	r1, r2, r6
 8012df0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8012df4:	bf08      	it	eq
 8012df6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8012dfa:	bd70      	pop	{r4, r5, r6, pc}
 8012dfc:	f1c4 040c 	rsb	r4, r4, #12
 8012e00:	f1c4 0520 	rsb	r5, r4, #32
 8012e04:	fa00 f304 	lsl.w	r3, r0, r4
 8012e08:	fa20 f005 	lsr.w	r0, r0, r5
 8012e0c:	fa01 f204 	lsl.w	r2, r1, r4
 8012e10:	ea40 0002 	orr.w	r0, r0, r2
 8012e14:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8012e18:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8012e1c:	f141 0100 	adc.w	r1, r1, #0
 8012e20:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8012e24:	bf08      	it	eq
 8012e26:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8012e2a:	bd70      	pop	{r4, r5, r6, pc}
 8012e2c:	f1c4 0520 	rsb	r5, r4, #32
 8012e30:	fa00 f205 	lsl.w	r2, r0, r5
 8012e34:	ea4e 0e02 	orr.w	lr, lr, r2
 8012e38:	fa20 f304 	lsr.w	r3, r0, r4
 8012e3c:	fa01 f205 	lsl.w	r2, r1, r5
 8012e40:	ea43 0302 	orr.w	r3, r3, r2
 8012e44:	fa21 f004 	lsr.w	r0, r1, r4
 8012e48:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8012e4c:	fa21 f204 	lsr.w	r2, r1, r4
 8012e50:	ea20 0002 	bic.w	r0, r0, r2
 8012e54:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8012e58:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8012e5c:	bf08      	it	eq
 8012e5e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8012e62:	bd70      	pop	{r4, r5, r6, pc}
 8012e64:	f094 0f00 	teq	r4, #0
 8012e68:	d10f      	bne.n	8012e8a <__aeabi_dmul+0x1c2>
 8012e6a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8012e6e:	0040      	lsls	r0, r0, #1
 8012e70:	eb41 0101 	adc.w	r1, r1, r1
 8012e74:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8012e78:	bf08      	it	eq
 8012e7a:	3c01      	subeq	r4, #1
 8012e7c:	d0f7      	beq.n	8012e6e <__aeabi_dmul+0x1a6>
 8012e7e:	ea41 0106 	orr.w	r1, r1, r6
 8012e82:	f095 0f00 	teq	r5, #0
 8012e86:	bf18      	it	ne
 8012e88:	4770      	bxne	lr
 8012e8a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8012e8e:	0052      	lsls	r2, r2, #1
 8012e90:	eb43 0303 	adc.w	r3, r3, r3
 8012e94:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8012e98:	bf08      	it	eq
 8012e9a:	3d01      	subeq	r5, #1
 8012e9c:	d0f7      	beq.n	8012e8e <__aeabi_dmul+0x1c6>
 8012e9e:	ea43 0306 	orr.w	r3, r3, r6
 8012ea2:	4770      	bx	lr
 8012ea4:	ea94 0f0c 	teq	r4, ip
 8012ea8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8012eac:	bf18      	it	ne
 8012eae:	ea95 0f0c 	teqne	r5, ip
 8012eb2:	d00c      	beq.n	8012ece <__aeabi_dmul+0x206>
 8012eb4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8012eb8:	bf18      	it	ne
 8012eba:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8012ebe:	d1d1      	bne.n	8012e64 <__aeabi_dmul+0x19c>
 8012ec0:	ea81 0103 	eor.w	r1, r1, r3
 8012ec4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8012ec8:	f04f 0000 	mov.w	r0, #0
 8012ecc:	bd70      	pop	{r4, r5, r6, pc}
 8012ece:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8012ed2:	bf06      	itte	eq
 8012ed4:	4610      	moveq	r0, r2
 8012ed6:	4619      	moveq	r1, r3
 8012ed8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8012edc:	d019      	beq.n	8012f12 <__aeabi_dmul+0x24a>
 8012ede:	ea94 0f0c 	teq	r4, ip
 8012ee2:	d102      	bne.n	8012eea <__aeabi_dmul+0x222>
 8012ee4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8012ee8:	d113      	bne.n	8012f12 <__aeabi_dmul+0x24a>
 8012eea:	ea95 0f0c 	teq	r5, ip
 8012eee:	d105      	bne.n	8012efc <__aeabi_dmul+0x234>
 8012ef0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8012ef4:	bf1c      	itt	ne
 8012ef6:	4610      	movne	r0, r2
 8012ef8:	4619      	movne	r1, r3
 8012efa:	d10a      	bne.n	8012f12 <__aeabi_dmul+0x24a>
 8012efc:	ea81 0103 	eor.w	r1, r1, r3
 8012f00:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8012f04:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8012f08:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8012f0c:	f04f 0000 	mov.w	r0, #0
 8012f10:	bd70      	pop	{r4, r5, r6, pc}
 8012f12:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8012f16:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8012f1a:	bd70      	pop	{r4, r5, r6, pc}

08012f1c <__aeabi_ddiv>:
 8012f1c:	b570      	push	{r4, r5, r6, lr}
 8012f1e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8012f22:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8012f26:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8012f2a:	bf1d      	ittte	ne
 8012f2c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8012f30:	ea94 0f0c 	teqne	r4, ip
 8012f34:	ea95 0f0c 	teqne	r5, ip
 8012f38:	f000 f8a7 	bleq	801308a <__aeabi_ddiv+0x16e>
 8012f3c:	eba4 0405 	sub.w	r4, r4, r5
 8012f40:	ea81 0e03 	eor.w	lr, r1, r3
 8012f44:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8012f48:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8012f4c:	f000 8088 	beq.w	8013060 <__aeabi_ddiv+0x144>
 8012f50:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8012f54:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8012f58:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8012f5c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8012f60:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8012f64:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8012f68:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8012f6c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8012f70:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8012f74:	429d      	cmp	r5, r3
 8012f76:	bf08      	it	eq
 8012f78:	4296      	cmpeq	r6, r2
 8012f7a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8012f7e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8012f82:	d202      	bcs.n	8012f8a <__aeabi_ddiv+0x6e>
 8012f84:	085b      	lsrs	r3, r3, #1
 8012f86:	ea4f 0232 	mov.w	r2, r2, rrx
 8012f8a:	1ab6      	subs	r6, r6, r2
 8012f8c:	eb65 0503 	sbc.w	r5, r5, r3
 8012f90:	085b      	lsrs	r3, r3, #1
 8012f92:	ea4f 0232 	mov.w	r2, r2, rrx
 8012f96:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8012f9a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8012f9e:	ebb6 0e02 	subs.w	lr, r6, r2
 8012fa2:	eb75 0e03 	sbcs.w	lr, r5, r3
 8012fa6:	bf22      	ittt	cs
 8012fa8:	1ab6      	subcs	r6, r6, r2
 8012faa:	4675      	movcs	r5, lr
 8012fac:	ea40 000c 	orrcs.w	r0, r0, ip
 8012fb0:	085b      	lsrs	r3, r3, #1
 8012fb2:	ea4f 0232 	mov.w	r2, r2, rrx
 8012fb6:	ebb6 0e02 	subs.w	lr, r6, r2
 8012fba:	eb75 0e03 	sbcs.w	lr, r5, r3
 8012fbe:	bf22      	ittt	cs
 8012fc0:	1ab6      	subcs	r6, r6, r2
 8012fc2:	4675      	movcs	r5, lr
 8012fc4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8012fc8:	085b      	lsrs	r3, r3, #1
 8012fca:	ea4f 0232 	mov.w	r2, r2, rrx
 8012fce:	ebb6 0e02 	subs.w	lr, r6, r2
 8012fd2:	eb75 0e03 	sbcs.w	lr, r5, r3
 8012fd6:	bf22      	ittt	cs
 8012fd8:	1ab6      	subcs	r6, r6, r2
 8012fda:	4675      	movcs	r5, lr
 8012fdc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8012fe0:	085b      	lsrs	r3, r3, #1
 8012fe2:	ea4f 0232 	mov.w	r2, r2, rrx
 8012fe6:	ebb6 0e02 	subs.w	lr, r6, r2
 8012fea:	eb75 0e03 	sbcs.w	lr, r5, r3
 8012fee:	bf22      	ittt	cs
 8012ff0:	1ab6      	subcs	r6, r6, r2
 8012ff2:	4675      	movcs	r5, lr
 8012ff4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8012ff8:	ea55 0e06 	orrs.w	lr, r5, r6
 8012ffc:	d018      	beq.n	8013030 <__aeabi_ddiv+0x114>
 8012ffe:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8013002:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8013006:	ea4f 1606 	mov.w	r6, r6, lsl #4
 801300a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 801300e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8013012:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8013016:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 801301a:	d1c0      	bne.n	8012f9e <__aeabi_ddiv+0x82>
 801301c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8013020:	d10b      	bne.n	801303a <__aeabi_ddiv+0x11e>
 8013022:	ea41 0100 	orr.w	r1, r1, r0
 8013026:	f04f 0000 	mov.w	r0, #0
 801302a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 801302e:	e7b6      	b.n	8012f9e <__aeabi_ddiv+0x82>
 8013030:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8013034:	bf04      	itt	eq
 8013036:	4301      	orreq	r1, r0
 8013038:	2000      	moveq	r0, #0
 801303a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 801303e:	bf88      	it	hi
 8013040:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8013044:	f63f aeaf 	bhi.w	8012da6 <__aeabi_dmul+0xde>
 8013048:	ebb5 0c03 	subs.w	ip, r5, r3
 801304c:	bf04      	itt	eq
 801304e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8013052:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8013056:	f150 0000 	adcs.w	r0, r0, #0
 801305a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 801305e:	bd70      	pop	{r4, r5, r6, pc}
 8013060:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8013064:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8013068:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 801306c:	bfc2      	ittt	gt
 801306e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8013072:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8013076:	bd70      	popgt	{r4, r5, r6, pc}
 8013078:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 801307c:	f04f 0e00 	mov.w	lr, #0
 8013080:	3c01      	subs	r4, #1
 8013082:	e690      	b.n	8012da6 <__aeabi_dmul+0xde>
 8013084:	ea45 0e06 	orr.w	lr, r5, r6
 8013088:	e68d      	b.n	8012da6 <__aeabi_dmul+0xde>
 801308a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 801308e:	ea94 0f0c 	teq	r4, ip
 8013092:	bf08      	it	eq
 8013094:	ea95 0f0c 	teqeq	r5, ip
 8013098:	f43f af3b 	beq.w	8012f12 <__aeabi_dmul+0x24a>
 801309c:	ea94 0f0c 	teq	r4, ip
 80130a0:	d10a      	bne.n	80130b8 <__aeabi_ddiv+0x19c>
 80130a2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80130a6:	f47f af34 	bne.w	8012f12 <__aeabi_dmul+0x24a>
 80130aa:	ea95 0f0c 	teq	r5, ip
 80130ae:	f47f af25 	bne.w	8012efc <__aeabi_dmul+0x234>
 80130b2:	4610      	mov	r0, r2
 80130b4:	4619      	mov	r1, r3
 80130b6:	e72c      	b.n	8012f12 <__aeabi_dmul+0x24a>
 80130b8:	ea95 0f0c 	teq	r5, ip
 80130bc:	d106      	bne.n	80130cc <__aeabi_ddiv+0x1b0>
 80130be:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80130c2:	f43f aefd 	beq.w	8012ec0 <__aeabi_dmul+0x1f8>
 80130c6:	4610      	mov	r0, r2
 80130c8:	4619      	mov	r1, r3
 80130ca:	e722      	b.n	8012f12 <__aeabi_dmul+0x24a>
 80130cc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80130d0:	bf18      	it	ne
 80130d2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80130d6:	f47f aec5 	bne.w	8012e64 <__aeabi_dmul+0x19c>
 80130da:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80130de:	f47f af0d 	bne.w	8012efc <__aeabi_dmul+0x234>
 80130e2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80130e6:	f47f aeeb 	bne.w	8012ec0 <__aeabi_dmul+0x1f8>
 80130ea:	e712      	b.n	8012f12 <__aeabi_dmul+0x24a>

080130ec <__aeabi_d2uiz>:
 80130ec:	004a      	lsls	r2, r1, #1
 80130ee:	d211      	bcs.n	8013114 <__aeabi_d2uiz+0x28>
 80130f0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80130f4:	d211      	bcs.n	801311a <__aeabi_d2uiz+0x2e>
 80130f6:	d50d      	bpl.n	8013114 <__aeabi_d2uiz+0x28>
 80130f8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80130fc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8013100:	d40e      	bmi.n	8013120 <__aeabi_d2uiz+0x34>
 8013102:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8013106:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 801310a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 801310e:	fa23 f002 	lsr.w	r0, r3, r2
 8013112:	4770      	bx	lr
 8013114:	f04f 0000 	mov.w	r0, #0
 8013118:	4770      	bx	lr
 801311a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 801311e:	d102      	bne.n	8013126 <__aeabi_d2uiz+0x3a>
 8013120:	f04f 30ff 	mov.w	r0, #4294967295
 8013124:	4770      	bx	lr
 8013126:	f04f 0000 	mov.w	r0, #0
 801312a:	4770      	bx	lr

0801312c <AFIO_INIT>:
 */
#include "RCC.h"
#include "AFIO.h"


void AFIO_INIT(void){
 801312c:	b480      	push	{r7}
 801312e:	af00      	add	r7, sp, #0
	//no remap of CAN
	AFIO->MAPR &= ~(AFIO_MAPR_CAN_REMAP_Msk);
 8013130:	4b07      	ldr	r3, [pc, #28]	; (8013150 <AFIO_INIT+0x24>)
 8013132:	685b      	ldr	r3, [r3, #4]
 8013134:	4a06      	ldr	r2, [pc, #24]	; (8013150 <AFIO_INIT+0x24>)
 8013136:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 801313a:	6053      	str	r3, [r2, #4]
	//No remap of USART3
	AFIO->MAPR &= ~(AFIO_MAPR_USART3_REMAP_Msk);
 801313c:	4b04      	ldr	r3, [pc, #16]	; (8013150 <AFIO_INIT+0x24>)
 801313e:	685b      	ldr	r3, [r3, #4]
 8013140:	4a03      	ldr	r2, [pc, #12]	; (8013150 <AFIO_INIT+0x24>)
 8013142:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8013146:	6053      	str	r3, [r2, #4]
}
 8013148:	bf00      	nop
 801314a:	46bd      	mov	sp, r7
 801314c:	bc80      	pop	{r7}
 801314e:	4770      	bx	lr
 8013150:	40010000 	.word	0x40010000

08013154 <CAN_Setup>:

/* ------------------------------- Configuration for CAN ---------------------------------*/
/*
 * */

void CAN_Setup(CAN_TypeDef *CANx, CAN_setupTypeDef *CANsetupStruct) {
 8013154:	b480      	push	{r7}
 8013156:	b083      	sub	sp, #12
 8013158:	af00      	add	r7, sp, #0
 801315a:	6078      	str	r0, [r7, #4]
 801315c:	6039      	str	r1, [r7, #0]
	/* Initialization request */
	CANx->MCR |= CAN_MCR_INRQ;
 801315e:	687b      	ldr	r3, [r7, #4]
 8013160:	681b      	ldr	r3, [r3, #0]
 8013162:	f043 0201 	orr.w	r2, r3, #1
 8013166:	687b      	ldr	r3, [r7, #4]
 8013168:	601a      	str	r2, [r3, #0]

	/*Request to exit Sleep mode */
	CANx->MCR &= ~CAN_MCR_SLEEP_Msk;
 801316a:	687b      	ldr	r3, [r7, #4]
 801316c:	681b      	ldr	r3, [r3, #0]
 801316e:	f023 0202 	bic.w	r2, r3, #2
 8013172:	687b      	ldr	r3, [r7, #4]
 8013174:	601a      	str	r2, [r3, #0]

	/* Wait for initialization mode */
	while (!(CAN_MSR_INAK & CANx->MSR))
 8013176:	bf00      	nop
 8013178:	687b      	ldr	r3, [r7, #4]
 801317a:	685b      	ldr	r3, [r3, #4]
 801317c:	f003 0301 	and.w	r3, r3, #1
 8013180:	2b00      	cmp	r3, #0
 8013182:	d0f9      	beq.n	8013178 <CAN_Setup+0x24>
		;

	/******************* SET MCR register configuration**************************/

	/* Set the time triggered communication mode */
	if (CANsetupStruct->TTCM == ENABLE) {
 8013184:	683b      	ldr	r3, [r7, #0]
 8013186:	781b      	ldrb	r3, [r3, #0]
 8013188:	2b01      	cmp	r3, #1
 801318a:	d106      	bne.n	801319a <CAN_Setup+0x46>
		CANx->MCR |= CAN_MCR_TTCM;
 801318c:	687b      	ldr	r3, [r7, #4]
 801318e:	681b      	ldr	r3, [r3, #0]
 8013190:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8013194:	687b      	ldr	r3, [r7, #4]
 8013196:	601a      	str	r2, [r3, #0]
 8013198:	e005      	b.n	80131a6 <CAN_Setup+0x52>
	} else {
		CANx->MCR &= ~(CAN_MCR_TTCM_Msk);
 801319a:	687b      	ldr	r3, [r7, #4]
 801319c:	681b      	ldr	r3, [r3, #0]
 801319e:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 80131a2:	687b      	ldr	r3, [r7, #4]
 80131a4:	601a      	str	r2, [r3, #0]
	}
	/* Set the automatic bus-off management */
	if (CANsetupStruct->ABOM == ENABLE) {
 80131a6:	683b      	ldr	r3, [r7, #0]
 80131a8:	785b      	ldrb	r3, [r3, #1]
 80131aa:	2b01      	cmp	r3, #1
 80131ac:	d106      	bne.n	80131bc <CAN_Setup+0x68>
		CANx->MCR |= CAN_MCR_ABOM;
 80131ae:	687b      	ldr	r3, [r7, #4]
 80131b0:	681b      	ldr	r3, [r3, #0]
 80131b2:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 80131b6:	687b      	ldr	r3, [r7, #4]
 80131b8:	601a      	str	r2, [r3, #0]
 80131ba:	e005      	b.n	80131c8 <CAN_Setup+0x74>
	} else {
		CANx->MCR &= ~(CAN_MCR_ABOM_Msk);
 80131bc:	687b      	ldr	r3, [r7, #4]
 80131be:	681b      	ldr	r3, [r3, #0]
 80131c0:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 80131c4:	687b      	ldr	r3, [r7, #4]
 80131c6:	601a      	str	r2, [r3, #0]
	}

	/* Set the automatic wake-up mode */
	if (CANsetupStruct->AWUM == ENABLE) {
 80131c8:	683b      	ldr	r3, [r7, #0]
 80131ca:	789b      	ldrb	r3, [r3, #2]
 80131cc:	2b01      	cmp	r3, #1
 80131ce:	d106      	bne.n	80131de <CAN_Setup+0x8a>
		CANx->MCR |= CAN_MCR_AWUM;
 80131d0:	687b      	ldr	r3, [r7, #4]
 80131d2:	681b      	ldr	r3, [r3, #0]
 80131d4:	f043 0220 	orr.w	r2, r3, #32
 80131d8:	687b      	ldr	r3, [r7, #4]
 80131da:	601a      	str	r2, [r3, #0]
 80131dc:	e005      	b.n	80131ea <CAN_Setup+0x96>
	} else {
		CANx->MCR &= ~(CAN_MCR_AWUM_Msk);
 80131de:	687b      	ldr	r3, [r7, #4]
 80131e0:	681b      	ldr	r3, [r3, #0]
 80131e2:	f023 0220 	bic.w	r2, r3, #32
 80131e6:	687b      	ldr	r3, [r7, #4]
 80131e8:	601a      	str	r2, [r3, #0]
	}

	/* Set the no automatic retransmission */
	if (CANsetupStruct->NART == ENABLE) {
 80131ea:	683b      	ldr	r3, [r7, #0]
 80131ec:	78db      	ldrb	r3, [r3, #3]
 80131ee:	2b01      	cmp	r3, #1
 80131f0:	d106      	bne.n	8013200 <CAN_Setup+0xac>
		CANx->MCR |= CAN_MCR_NART;
 80131f2:	687b      	ldr	r3, [r7, #4]
 80131f4:	681b      	ldr	r3, [r3, #0]
 80131f6:	f043 0210 	orr.w	r2, r3, #16
 80131fa:	687b      	ldr	r3, [r7, #4]
 80131fc:	601a      	str	r2, [r3, #0]
 80131fe:	e005      	b.n	801320c <CAN_Setup+0xb8>
	} else {
		CANx->MCR &= ~(CAN_MCR_NART_Msk);
 8013200:	687b      	ldr	r3, [r7, #4]
 8013202:	681b      	ldr	r3, [r3, #0]
 8013204:	f023 0210 	bic.w	r2, r3, #16
 8013208:	687b      	ldr	r3, [r7, #4]
 801320a:	601a      	str	r2, [r3, #0]
	}

	/* Set the transmit FIFO priority */
	if (CANsetupStruct->TXFP == ENABLE) {
 801320c:	683b      	ldr	r3, [r7, #0]
 801320e:	795b      	ldrb	r3, [r3, #5]
 8013210:	2b01      	cmp	r3, #1
 8013212:	d106      	bne.n	8013222 <CAN_Setup+0xce>
		CANx->MCR &= ~(CAN_MCR_TXFP_Msk);
 8013214:	687b      	ldr	r3, [r7, #4]
 8013216:	681b      	ldr	r3, [r3, #0]
 8013218:	f023 0204 	bic.w	r2, r3, #4
 801321c:	687b      	ldr	r3, [r7, #4]
 801321e:	601a      	str	r2, [r3, #0]
 8013220:	e005      	b.n	801322e <CAN_Setup+0xda>
	} else {
		CANx->MCR |= CAN_MCR_TXFP;
 8013222:	687b      	ldr	r3, [r7, #4]
 8013224:	681b      	ldr	r3, [r3, #0]
 8013226:	f043 0204 	orr.w	r2, r3, #4
 801322a:	687b      	ldr	r3, [r7, #4]
 801322c:	601a      	str	r2, [r3, #0]
	}
	if(CANsetupStruct->RFLM == ENABLE){
 801322e:	683b      	ldr	r3, [r7, #0]
 8013230:	791b      	ldrb	r3, [r3, #4]
 8013232:	2b01      	cmp	r3, #1
 8013234:	d106      	bne.n	8013244 <CAN_Setup+0xf0>
		//FIFO Overload Lock Mode
		CANx->MCR |= CAN_MCR_RFLM;
 8013236:	687b      	ldr	r3, [r7, #4]
 8013238:	681b      	ldr	r3, [r3, #0]
 801323a:	f043 0208 	orr.w	r2, r3, #8
 801323e:	687b      	ldr	r3, [r7, #4]
 8013240:	601a      	str	r2, [r3, #0]
 8013242:	e005      	b.n	8013250 <CAN_Setup+0xfc>
	}else{
		CANx->MCR &= ~(CAN_MCR_RFLM_Msk);
 8013244:	687b      	ldr	r3, [r7, #4]
 8013246:	681b      	ldr	r3, [r3, #0]
 8013248:	f023 0208 	bic.w	r2, r3, #8
 801324c:	687b      	ldr	r3, [r7, #4]
 801324e:	601a      	str	r2, [r3, #0]
	 * tBS2 = tq * (TS2[2:0] + 1)  = 0.111 * (0+1)  = 0.111 micro sec
	 * NominalBitTime = 1 * tq + tBS1 + tBS2 = 0.111 + 0.777 + 0.111 = 0.999 micro sec
	 * Boudrate = 1 / NominalBitTime = 1 Mbps
	 *
	 * */
	CANx->BTR = CAN_BTR;
 8013250:	687b      	ldr	r3, [r7, #4]
 8013252:	4a03      	ldr	r2, [pc, #12]	; (8013260 <CAN_Setup+0x10c>)
 8013254:	61da      	str	r2, [r3, #28]
	//set all filters to our can (other can must deactivate)
	//CANx->FMR &= ~(CAN_FMR_CAN2SB_Msk);

}
 8013256:	bf00      	nop
 8013258:	370c      	adds	r7, #12
 801325a:	46bd      	mov	sp, r7
 801325c:	bc80      	pop	{r7}
 801325e:	4770      	bx	lr
 8013260:	001e000f 	.word	0x001e000f

08013264 <CAN_Normal>:
}

/*
 * ---------------------------------- CAN set normal mode ---------------------------------
 */
void CAN_Normal(CAN_TypeDef *CANx) {
 8013264:	b480      	push	{r7}
 8013266:	b083      	sub	sp, #12
 8013268:	af00      	add	r7, sp, #0
 801326a:	6078      	str	r0, [r7, #4]

	CANx->MCR &= ~(CAN_MCR_INRQ_Msk | CAN_MCR_SLEEP_Msk); //normal operating mode, reset(INRQ,SLEEP)
 801326c:	687b      	ldr	r3, [r7, #4]
 801326e:	681b      	ldr	r3, [r3, #0]
 8013270:	f023 0203 	bic.w	r2, r3, #3
 8013274:	687b      	ldr	r3, [r7, #4]
 8013276:	601a      	str	r2, [r3, #0]

	while (CANx->MSR & CAN_MSR_INAK)
 8013278:	bf00      	nop
 801327a:	687b      	ldr	r3, [r7, #4]
 801327c:	685b      	ldr	r3, [r3, #4]
 801327e:	f003 0301 	and.w	r3, r3, #1
 8013282:	2b00      	cmp	r3, #0
 8013284:	d1f9      	bne.n	801327a <CAN_Normal+0x16>
		;

}
 8013286:	bf00      	nop
 8013288:	bf00      	nop
 801328a:	370c      	adds	r7, #12
 801328c:	46bd      	mov	sp, r7
 801328e:	bc80      	pop	{r7}
 8013290:	4770      	bx	lr

08013292 <CAN_Transmit>:

/*
 * note : para MailboxNumber Can be :TX_MAILBOX_0, TX_MAILBOX_1, TX_MAILBOX_2
 *------------------------------------ CAN Transmission ----------------------------------
 */
void CAN_Transmit(CAN_TypeDef *CANx, CAN_msg *msg) {
 8013292:	b480      	push	{r7}
 8013294:	b085      	sub	sp, #20
 8013296:	af00      	add	r7, sp, #0
 8013298:	6078      	str	r0, [r7, #4]
 801329a:	6039      	str	r1, [r7, #0]
	/* check if transmission mailbox is empty */
	uint8_t mailBoxIndex = 10;
 801329c:	230a      	movs	r3, #10
 801329e:	73fb      	strb	r3, [r7, #15]
	while (mailBoxIndex == 10){
 80132a0:	e019      	b.n	80132d6 <CAN_Transmit+0x44>
		if(CANx->TSR & CAN_TSR_TME0){
 80132a2:	687b      	ldr	r3, [r7, #4]
 80132a4:	689b      	ldr	r3, [r3, #8]
 80132a6:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80132aa:	2b00      	cmp	r3, #0
 80132ac:	d002      	beq.n	80132b4 <CAN_Transmit+0x22>
			mailBoxIndex = CAN_TSR_TME0 >> 27;
 80132ae:	2300      	movs	r3, #0
 80132b0:	73fb      	strb	r3, [r7, #15]
 80132b2:	e010      	b.n	80132d6 <CAN_Transmit+0x44>
		}else if(CANx->TSR & CAN_TSR_TME1){
 80132b4:	687b      	ldr	r3, [r7, #4]
 80132b6:	689b      	ldr	r3, [r3, #8]
 80132b8:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80132bc:	2b00      	cmp	r3, #0
 80132be:	d002      	beq.n	80132c6 <CAN_Transmit+0x34>
			mailBoxIndex = CAN_TSR_TME1 >> 27;
 80132c0:	2301      	movs	r3, #1
 80132c2:	73fb      	strb	r3, [r7, #15]
 80132c4:	e007      	b.n	80132d6 <CAN_Transmit+0x44>
		}else if (CANx->TSR & CAN_TSR_TME2) {
 80132c6:	687b      	ldr	r3, [r7, #4]
 80132c8:	689b      	ldr	r3, [r3, #8]
 80132ca:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80132ce:	2b00      	cmp	r3, #0
 80132d0:	d001      	beq.n	80132d6 <CAN_Transmit+0x44>
			mailBoxIndex = CAN_TSR_TME2 >> 27;
 80132d2:	2302      	movs	r3, #2
 80132d4:	73fb      	strb	r3, [r7, #15]
	while (mailBoxIndex == 10){
 80132d6:	7bfb      	ldrb	r3, [r7, #15]
 80132d8:	2b0a      	cmp	r3, #10
 80132da:	d0e2      	beq.n	80132a2 <CAN_Transmit+0x10>
		}
	}
	 // ------ check if transmission mailbox  is empty ------------------------------------

	CANx->sTxMailBox[mailBoxIndex].TIR = (uint32_t) 0; // Reset TIR register
 80132dc:	7bfb      	ldrb	r3, [r7, #15]
 80132de:	687a      	ldr	r2, [r7, #4]
 80132e0:	3318      	adds	r3, #24
 80132e2:	011b      	lsls	r3, r3, #4
 80132e4:	4413      	add	r3, r2
 80132e6:	2200      	movs	r2, #0
 80132e8:	601a      	str	r2, [r3, #0]

	// Setup identifier information   ?<==================
	if (msg->format == STANDARD_FORMAT) {
 80132ea:	683b      	ldr	r3, [r7, #0]
 80132ec:	7b5b      	ldrb	r3, [r3, #13]
 80132ee:	2b00      	cmp	r3, #0
 80132f0:	d110      	bne.n	8013314 <CAN_Transmit+0x82>
		CANx->sTxMailBox[mailBoxIndex].TIR |= (uint32_t) (msg->id << 21);
 80132f2:	7bfb      	ldrb	r3, [r7, #15]
 80132f4:	687a      	ldr	r2, [r7, #4]
 80132f6:	3318      	adds	r3, #24
 80132f8:	011b      	lsls	r3, r3, #4
 80132fa:	4413      	add	r3, r2
 80132fc:	6819      	ldr	r1, [r3, #0]
 80132fe:	683b      	ldr	r3, [r7, #0]
 8013300:	681b      	ldr	r3, [r3, #0]
 8013302:	055a      	lsls	r2, r3, #21
 8013304:	7bfb      	ldrb	r3, [r7, #15]
 8013306:	430a      	orrs	r2, r1
 8013308:	6879      	ldr	r1, [r7, #4]
 801330a:	3318      	adds	r3, #24
 801330c:	011b      	lsls	r3, r3, #4
 801330e:	440b      	add	r3, r1
 8013310:	601a      	str	r2, [r3, #0]
 8013312:	e011      	b.n	8013338 <CAN_Transmit+0xa6>
	} else {
		// Extended ID
		CANx->sTxMailBox[mailBoxIndex].TIR |= (uint32_t) (msg->id << 3)
 8013314:	7bfb      	ldrb	r3, [r7, #15]
 8013316:	687a      	ldr	r2, [r7, #4]
 8013318:	3318      	adds	r3, #24
 801331a:	011b      	lsls	r3, r3, #4
 801331c:	4413      	add	r3, r2
 801331e:	681a      	ldr	r2, [r3, #0]
 8013320:	683b      	ldr	r3, [r7, #0]
 8013322:	681b      	ldr	r3, [r3, #0]
 8013324:	00db      	lsls	r3, r3, #3
 8013326:	431a      	orrs	r2, r3
 8013328:	7bfb      	ldrb	r3, [r7, #15]
 801332a:	f042 0204 	orr.w	r2, r2, #4
 801332e:	6879      	ldr	r1, [r7, #4]
 8013330:	3318      	adds	r3, #24
 8013332:	011b      	lsls	r3, r3, #4
 8013334:	440b      	add	r3, r1
 8013336:	601a      	str	r2, [r3, #0]
				| CAN_TI0R_IDE;
	}

	// Setup type information
	if (msg->type == DATA_FRAME) {
 8013338:	683b      	ldr	r3, [r7, #0]
 801333a:	7b9b      	ldrb	r3, [r3, #14]
 801333c:	2b00      	cmp	r3, #0
 801333e:	d13c      	bne.n	80133ba <CAN_Transmit+0x128>
		// DATA FRAME
		/*reset transmit data registers*/
		CANx->sTxMailBox[mailBoxIndex].TDLR = 0;
 8013340:	7bfb      	ldrb	r3, [r7, #15]
 8013342:	687a      	ldr	r2, [r7, #4]
 8013344:	011b      	lsls	r3, r3, #4
 8013346:	4413      	add	r3, r2
 8013348:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 801334c:	2200      	movs	r2, #0
 801334e:	601a      	str	r2, [r3, #0]
		CANx->sTxMailBox[mailBoxIndex].TDHR = 0;
 8013350:	7bfb      	ldrb	r3, [r7, #15]
 8013352:	687a      	ldr	r2, [r7, #4]
 8013354:	011b      	lsls	r3, r3, #4
 8013356:	4413      	add	r3, r2
 8013358:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 801335c:	2200      	movs	r2, #0
 801335e:	601a      	str	r2, [r3, #0]

		CANx->sTxMailBox[mailBoxIndex].TDLR = (((uint32_t) msg->data[3] << 24)
 8013360:	683b      	ldr	r3, [r7, #0]
 8013362:	79db      	ldrb	r3, [r3, #7]
 8013364:	061a      	lsls	r2, r3, #24
				| ((uint32_t) msg->data[2] << 16)
 8013366:	683b      	ldr	r3, [r7, #0]
 8013368:	799b      	ldrb	r3, [r3, #6]
 801336a:	041b      	lsls	r3, r3, #16
 801336c:	431a      	orrs	r2, r3
				| ((uint32_t) msg->data[1] << 8) | ((uint32_t) msg->data[0]));
 801336e:	683b      	ldr	r3, [r7, #0]
 8013370:	795b      	ldrb	r3, [r3, #5]
 8013372:	021b      	lsls	r3, r3, #8
 8013374:	431a      	orrs	r2, r3
 8013376:	683b      	ldr	r3, [r7, #0]
 8013378:	791b      	ldrb	r3, [r3, #4]
 801337a:	4619      	mov	r1, r3
		CANx->sTxMailBox[mailBoxIndex].TDLR = (((uint32_t) msg->data[3] << 24)
 801337c:	7bfb      	ldrb	r3, [r7, #15]
				| ((uint32_t) msg->data[1] << 8) | ((uint32_t) msg->data[0]));
 801337e:	430a      	orrs	r2, r1
		CANx->sTxMailBox[mailBoxIndex].TDLR = (((uint32_t) msg->data[3] << 24)
 8013380:	6879      	ldr	r1, [r7, #4]
 8013382:	011b      	lsls	r3, r3, #4
 8013384:	440b      	add	r3, r1
 8013386:	f503 73c4 	add.w	r3, r3, #392	; 0x188
 801338a:	601a      	str	r2, [r3, #0]

		CANx->sTxMailBox[mailBoxIndex].TDHR = (((uint32_t) msg->data[7] << 24)
 801338c:	683b      	ldr	r3, [r7, #0]
 801338e:	7adb      	ldrb	r3, [r3, #11]
 8013390:	061a      	lsls	r2, r3, #24
				| ((uint32_t) msg->data[6] << 16)
 8013392:	683b      	ldr	r3, [r7, #0]
 8013394:	7a9b      	ldrb	r3, [r3, #10]
 8013396:	041b      	lsls	r3, r3, #16
 8013398:	431a      	orrs	r2, r3
				| ((uint32_t) msg->data[5] << 8) | ((uint32_t) msg->data[4]));
 801339a:	683b      	ldr	r3, [r7, #0]
 801339c:	7a5b      	ldrb	r3, [r3, #9]
 801339e:	021b      	lsls	r3, r3, #8
 80133a0:	431a      	orrs	r2, r3
 80133a2:	683b      	ldr	r3, [r7, #0]
 80133a4:	7a1b      	ldrb	r3, [r3, #8]
 80133a6:	4619      	mov	r1, r3
		CANx->sTxMailBox[mailBoxIndex].TDHR = (((uint32_t) msg->data[7] << 24)
 80133a8:	7bfb      	ldrb	r3, [r7, #15]
				| ((uint32_t) msg->data[5] << 8) | ((uint32_t) msg->data[4]));
 80133aa:	430a      	orrs	r2, r1
		CANx->sTxMailBox[mailBoxIndex].TDHR = (((uint32_t) msg->data[7] << 24)
 80133ac:	6879      	ldr	r1, [r7, #4]
 80133ae:	011b      	lsls	r3, r3, #4
 80133b0:	440b      	add	r3, r1
 80133b2:	f503 73c6 	add.w	r3, r3, #396	; 0x18c
 80133b6:	601a      	str	r2, [r3, #0]
 80133b8:	e00d      	b.n	80133d6 <CAN_Transmit+0x144>
	} else {
		// REMOTE FRAME
		CANx->sTxMailBox[mailBoxIndex].TIR |= (CAN_TI0R_RTR);
 80133ba:	7bfb      	ldrb	r3, [r7, #15]
 80133bc:	687a      	ldr	r2, [r7, #4]
 80133be:	3318      	adds	r3, #24
 80133c0:	011b      	lsls	r3, r3, #4
 80133c2:	4413      	add	r3, r2
 80133c4:	681a      	ldr	r2, [r3, #0]
 80133c6:	7bfb      	ldrb	r3, [r7, #15]
 80133c8:	f042 0202 	orr.w	r2, r2, #2
 80133cc:	6879      	ldr	r1, [r7, #4]
 80133ce:	3318      	adds	r3, #24
 80133d0:	011b      	lsls	r3, r3, #4
 80133d2:	440b      	add	r3, r1
 80133d4:	601a      	str	r2, [r3, #0]
	}

	// Setup Can frame Data length Code
	CANx->sTxMailBox[mailBoxIndex].TDTR &= ~CAN_TDT0R_DLC;
 80133d6:	7bfb      	ldrb	r3, [r7, #15]
 80133d8:	687a      	ldr	r2, [r7, #4]
 80133da:	3318      	adds	r3, #24
 80133dc:	011b      	lsls	r3, r3, #4
 80133de:	4413      	add	r3, r2
 80133e0:	3304      	adds	r3, #4
 80133e2:	681a      	ldr	r2, [r3, #0]
 80133e4:	7bfb      	ldrb	r3, [r7, #15]
 80133e6:	f022 020f 	bic.w	r2, r2, #15
 80133ea:	6879      	ldr	r1, [r7, #4]
 80133ec:	3318      	adds	r3, #24
 80133ee:	011b      	lsls	r3, r3, #4
 80133f0:	440b      	add	r3, r1
 80133f2:	3304      	adds	r3, #4
 80133f4:	601a      	str	r2, [r3, #0]
	CANx->sTxMailBox[mailBoxIndex].TDTR |= (msg->length & CAN_TDT0R_DLC);
 80133f6:	7bfb      	ldrb	r3, [r7, #15]
 80133f8:	687a      	ldr	r2, [r7, #4]
 80133fa:	3318      	adds	r3, #24
 80133fc:	011b      	lsls	r3, r3, #4
 80133fe:	4413      	add	r3, r2
 8013400:	3304      	adds	r3, #4
 8013402:	6819      	ldr	r1, [r3, #0]
 8013404:	683b      	ldr	r3, [r7, #0]
 8013406:	7b1b      	ldrb	r3, [r3, #12]
 8013408:	f003 020f 	and.w	r2, r3, #15
 801340c:	7bfb      	ldrb	r3, [r7, #15]
 801340e:	430a      	orrs	r2, r1
 8013410:	6879      	ldr	r1, [r7, #4]
 8013412:	3318      	adds	r3, #24
 8013414:	011b      	lsls	r3, r3, #4
 8013416:	440b      	add	r3, r1
 8013418:	3304      	adds	r3, #4
 801341a:	601a      	str	r2, [r3, #0]

	/* Transmit Mailbox Request */
	CANx->sTxMailBox[mailBoxIndex].TIR |= CAN_TI0R_TXRQ;
 801341c:	7bfb      	ldrb	r3, [r7, #15]
 801341e:	687a      	ldr	r2, [r7, #4]
 8013420:	3318      	adds	r3, #24
 8013422:	011b      	lsls	r3, r3, #4
 8013424:	4413      	add	r3, r2
 8013426:	681a      	ldr	r2, [r3, #0]
 8013428:	7bfb      	ldrb	r3, [r7, #15]
 801342a:	f042 0201 	orr.w	r2, r2, #1
 801342e:	6879      	ldr	r1, [r7, #4]
 8013430:	3318      	adds	r3, #24
 8013432:	011b      	lsls	r3, r3, #4
 8013434:	440b      	add	r3, r1
 8013436:	601a      	str	r2, [r3, #0]
}
 8013438:	bf00      	nop
 801343a:	3714      	adds	r7, #20
 801343c:	46bd      	mov	sp, r7
 801343e:	bc80      	pop	{r7}
 8013440:	4770      	bx	lr

08013442 <CAN_Receive>:


/* -------------------------------      CAN Receiving     ------------------------------- */
// note para FifoNumber can be CAN_FIFO0, CAN_FIFO1
void CAN_Receive(CAN_TypeDef *CANx, uint8_t FifoNumber, CAN_msg *msg) {
 8013442:	b480      	push	{r7}
 8013444:	b087      	sub	sp, #28
 8013446:	af00      	add	r7, sp, #0
 8013448:	60f8      	str	r0, [r7, #12]
 801344a:	460b      	mov	r3, r1
 801344c:	607a      	str	r2, [r7, #4]
 801344e:	72fb      	strb	r3, [r7, #11]

	// Read identifier information
	if ((CANx->sFIFOMailBox[FifoNumber].RIR & CAN_TI0R_IDE) == 0) {
 8013450:	7afb      	ldrb	r3, [r7, #11]
 8013452:	68fa      	ldr	r2, [r7, #12]
 8013454:	331b      	adds	r3, #27
 8013456:	011b      	lsls	r3, r3, #4
 8013458:	4413      	add	r3, r2
 801345a:	681b      	ldr	r3, [r3, #0]
 801345c:	f003 0304 	and.w	r3, r3, #4
 8013460:	2b00      	cmp	r3, #0
 8013462:	d10e      	bne.n	8013482 <CAN_Receive+0x40>
		// Standard ID

		msg->format = STANDARD_FORMAT;
 8013464:	687b      	ldr	r3, [r7, #4]
 8013466:	2200      	movs	r2, #0
 8013468:	735a      	strb	r2, [r3, #13]

		msg->id = (uint32_t) 0x000007FF
				& (CANx->sFIFOMailBox[FifoNumber].RIR >> 21);
 801346a:	7afb      	ldrb	r3, [r7, #11]
 801346c:	68fa      	ldr	r2, [r7, #12]
 801346e:	331b      	adds	r3, #27
 8013470:	011b      	lsls	r3, r3, #4
 8013472:	4413      	add	r3, r2
 8013474:	681b      	ldr	r3, [r3, #0]
 8013476:	0d5b      	lsrs	r3, r3, #21
 8013478:	f3c3 020a 	ubfx	r2, r3, #0, #11
		msg->id = (uint32_t) 0x000007FF
 801347c:	687b      	ldr	r3, [r7, #4]
 801347e:	601a      	str	r2, [r3, #0]
 8013480:	e00d      	b.n	801349e <CAN_Receive+0x5c>
	} else {
		// Extended ID
		msg->format = EXTENDED_FORMAT;
 8013482:	687b      	ldr	r3, [r7, #4]
 8013484:	2201      	movs	r2, #1
 8013486:	735a      	strb	r2, [r3, #13]

		msg->id = (uint32_t) 0x0003FFFF
				& (CANx->sFIFOMailBox[FifoNumber].RIR >> 3);
 8013488:	7afb      	ldrb	r3, [r7, #11]
 801348a:	68fa      	ldr	r2, [r7, #12]
 801348c:	331b      	adds	r3, #27
 801348e:	011b      	lsls	r3, r3, #4
 8013490:	4413      	add	r3, r2
 8013492:	681b      	ldr	r3, [r3, #0]
 8013494:	08db      	lsrs	r3, r3, #3
 8013496:	f3c3 0211 	ubfx	r2, r3, #0, #18
		msg->id = (uint32_t) 0x0003FFFF
 801349a:	687b      	ldr	r3, [r7, #4]
 801349c:	601a      	str	r2, [r3, #0]
	}

	// Read type information

	if ((CANx->sFIFOMailBox[FifoNumber].RIR & CAN_TI0R_RTR) == 0) {
 801349e:	7afb      	ldrb	r3, [r7, #11]
 80134a0:	68fa      	ldr	r2, [r7, #12]
 80134a2:	331b      	adds	r3, #27
 80134a4:	011b      	lsls	r3, r3, #4
 80134a6:	4413      	add	r3, r2
 80134a8:	681b      	ldr	r3, [r3, #0]
 80134aa:	f003 0302 	and.w	r3, r3, #2
 80134ae:	2b00      	cmp	r3, #0
 80134b0:	d103      	bne.n	80134ba <CAN_Receive+0x78>

		msg->type = DATA_FRAME;                     // DATA   FRAME
 80134b2:	687b      	ldr	r3, [r7, #4]
 80134b4:	2200      	movs	r2, #0
 80134b6:	739a      	strb	r2, [r3, #14]
 80134b8:	e002      	b.n	80134c0 <CAN_Receive+0x7e>

	} else {
		msg->type = REMOTE_FRAME;                   // REMOTE FRAME
 80134ba:	687b      	ldr	r3, [r7, #4]
 80134bc:	2201      	movs	r2, #1
 80134be:	739a      	strb	r2, [r3, #14]
	}

	// Read length (number of received bytes)
	msg->length = (uint8_t) 0x0000000F & CANx->sFIFOMailBox[FifoNumber].RDTR;
 80134c0:	7afb      	ldrb	r3, [r7, #11]
 80134c2:	68fa      	ldr	r2, [r7, #12]
 80134c4:	331b      	adds	r3, #27
 80134c6:	011b      	lsls	r3, r3, #4
 80134c8:	4413      	add	r3, r2
 80134ca:	3304      	adds	r3, #4
 80134cc:	681b      	ldr	r3, [r3, #0]
 80134ce:	b2db      	uxtb	r3, r3
 80134d0:	f003 030f 	and.w	r3, r3, #15
 80134d4:	b2da      	uxtb	r2, r3
 80134d6:	687b      	ldr	r3, [r7, #4]
 80134d8:	731a      	strb	r2, [r3, #12]

	// Read data bytes
	uint8_t ReceivDataCounter;

	for (ReceivDataCounter = 0; ReceivDataCounter < msg->length;
 80134da:	2300      	movs	r3, #0
 80134dc:	75fb      	strb	r3, [r7, #23]
 80134de:	e027      	b.n	8013530 <CAN_Receive+0xee>
			ReceivDataCounter++)

			{
		if (ReceivDataCounter < 4) /*get Data from low register*/
 80134e0:	7dfb      	ldrb	r3, [r7, #23]
 80134e2:	2b03      	cmp	r3, #3
 80134e4:	d810      	bhi.n	8013508 <CAN_Receive+0xc6>
		{
			msg->data[ReceivDataCounter] = (CANx->sFIFOMailBox[FifoNumber].RDLR
 80134e6:	7afb      	ldrb	r3, [r7, #11]
 80134e8:	68fa      	ldr	r2, [r7, #12]
 80134ea:	011b      	lsls	r3, r3, #4
 80134ec:	4413      	add	r3, r2
 80134ee:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 80134f2:	681a      	ldr	r2, [r3, #0]
					>> (ReceivDataCounter * 8)) & 0xFF; //get Data from low register byte by byte
 80134f4:	7dfb      	ldrb	r3, [r7, #23]
 80134f6:	00db      	lsls	r3, r3, #3
 80134f8:	40da      	lsrs	r2, r3
			msg->data[ReceivDataCounter] = (CANx->sFIFOMailBox[FifoNumber].RDLR
 80134fa:	7dfb      	ldrb	r3, [r7, #23]
 80134fc:	b2d1      	uxtb	r1, r2
 80134fe:	687a      	ldr	r2, [r7, #4]
 8013500:	4413      	add	r3, r2
 8013502:	460a      	mov	r2, r1
 8013504:	711a      	strb	r2, [r3, #4]
 8013506:	e010      	b.n	801352a <CAN_Receive+0xe8>
		} else /*get Data from high register*/
		{
			msg->data[ReceivDataCounter] = (CANx->sFIFOMailBox[FifoNumber].RDHR
 8013508:	7afb      	ldrb	r3, [r7, #11]
 801350a:	68fa      	ldr	r2, [r7, #12]
 801350c:	011b      	lsls	r3, r3, #4
 801350e:	4413      	add	r3, r2
 8013510:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 8013514:	681a      	ldr	r2, [r3, #0]
					>> ((ReceivDataCounter - 4) * 8)) & 0xFF; //get Data from high register byte by byte
 8013516:	7dfb      	ldrb	r3, [r7, #23]
 8013518:	3b04      	subs	r3, #4
 801351a:	00db      	lsls	r3, r3, #3
 801351c:	40da      	lsrs	r2, r3
			msg->data[ReceivDataCounter] = (CANx->sFIFOMailBox[FifoNumber].RDHR
 801351e:	7dfb      	ldrb	r3, [r7, #23]
 8013520:	b2d1      	uxtb	r1, r2
 8013522:	687a      	ldr	r2, [r7, #4]
 8013524:	4413      	add	r3, r2
 8013526:	460a      	mov	r2, r1
 8013528:	711a      	strb	r2, [r3, #4]
			ReceivDataCounter++)
 801352a:	7dfb      	ldrb	r3, [r7, #23]
 801352c:	3301      	adds	r3, #1
 801352e:	75fb      	strb	r3, [r7, #23]
	for (ReceivDataCounter = 0; ReceivDataCounter < msg->length;
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	7b1b      	ldrb	r3, [r3, #12]
 8013534:	7dfa      	ldrb	r2, [r7, #23]
 8013536:	429a      	cmp	r2, r3
 8013538:	d3d2      	bcc.n	80134e0 <CAN_Receive+0x9e>
		}

	}

	if (FifoNumber == CAN_FIFO0) //check for input FIFO to release
 801353a:	7afb      	ldrb	r3, [r7, #11]
 801353c:	2b00      	cmp	r3, #0
 801353e:	d106      	bne.n	801354e <CAN_Receive+0x10c>
	{

		CANx->RF0R |= CAN_RF0R_RFOM0;  //release FIFO 0
 8013540:	68fb      	ldr	r3, [r7, #12]
 8013542:	68db      	ldr	r3, [r3, #12]
 8013544:	f043 0220 	orr.w	r2, r3, #32
 8013548:	68fb      	ldr	r3, [r7, #12]
 801354a:	60da      	str	r2, [r3, #12]
 801354c:	e008      	b.n	8013560 <CAN_Receive+0x11e>
	}

	else if (FifoNumber == CAN_FIFO1) {
 801354e:	7afb      	ldrb	r3, [r7, #11]
 8013550:	2b01      	cmp	r3, #1
 8013552:	d105      	bne.n	8013560 <CAN_Receive+0x11e>

		CANx->RF1R |= CAN_RF1R_RFOM1;  //release FIFO 1
 8013554:	68fb      	ldr	r3, [r7, #12]
 8013556:	691b      	ldr	r3, [r3, #16]
 8013558:	f043 0220 	orr.w	r2, r3, #32
 801355c:	68fb      	ldr	r3, [r7, #12]
 801355e:	611a      	str	r2, [r3, #16]

	else {

		/*wrong FIFO number input*/
	}
	msg->ActiveFlag = ENABLE;
 8013560:	687b      	ldr	r3, [r7, #4]
 8013562:	2201      	movs	r2, #1
 8013564:	73da      	strb	r2, [r3, #15]
}
 8013566:	bf00      	nop
 8013568:	371c      	adds	r7, #28
 801356a:	46bd      	mov	sp, r7
 801356c:	bc80      	pop	{r7}
 801356e:	4770      	bx	lr

08013570 <CAN_Interrupt_Enable>:
/*
 * ------------------------------------ CAN interrupt ------------------------------------
 */

void CAN_Interrupt_Enable(CAN_TypeDef *CANx, uint32_t CanInterruptType,
		FunctionalState InterruptNewState) {
 8013570:	b480      	push	{r7}
 8013572:	b085      	sub	sp, #20
 8013574:	af00      	add	r7, sp, #0
 8013576:	60f8      	str	r0, [r7, #12]
 8013578:	60b9      	str	r1, [r7, #8]
 801357a:	4613      	mov	r3, r2
 801357c:	71fb      	strb	r3, [r7, #7]

	if (InterruptNewState == ENABLE) //check for input new state of input interrupt
 801357e:	79fb      	ldrb	r3, [r7, #7]
 8013580:	2b01      	cmp	r3, #1
 8013582:	d106      	bne.n	8013592 <CAN_Interrupt_Enable+0x22>
			{

		CANx->IER |= CanInterruptType; // Enable the selected CANx interrupt
 8013584:	68fb      	ldr	r3, [r7, #12]
 8013586:	695a      	ldr	r2, [r3, #20]
 8013588:	68bb      	ldr	r3, [r7, #8]
 801358a:	431a      	orrs	r2, r3
 801358c:	68fb      	ldr	r3, [r7, #12]
 801358e:	615a      	str	r2, [r3, #20]
		CANx->IER &= ~CanInterruptType; // Disable the selected CANx interrupt

	} else {
		/*WRONG STATE */
	}
}
 8013590:	e009      	b.n	80135a6 <CAN_Interrupt_Enable+0x36>
	} else if (InterruptNewState == DISABLE) {
 8013592:	79fb      	ldrb	r3, [r7, #7]
 8013594:	2b00      	cmp	r3, #0
 8013596:	d106      	bne.n	80135a6 <CAN_Interrupt_Enable+0x36>
		CANx->IER &= ~CanInterruptType; // Disable the selected CANx interrupt
 8013598:	68fb      	ldr	r3, [r7, #12]
 801359a:	695a      	ldr	r2, [r3, #20]
 801359c:	68bb      	ldr	r3, [r7, #8]
 801359e:	43db      	mvns	r3, r3
 80135a0:	401a      	ands	r2, r3
 80135a2:	68fb      	ldr	r3, [r7, #12]
 80135a4:	615a      	str	r2, [r3, #20]
}
 80135a6:	bf00      	nop
 80135a8:	3714      	adds	r7, #20
 80135aa:	46bd      	mov	sp, r7
 80135ac:	bc80      	pop	{r7}
 80135ae:	4770      	bx	lr

080135b0 <CAN_ConfigFilter>:
	return ErrorcodeType; //Return the error code
}


void CAN_ConfigFilter(CAN_TypeDef *CANx, CAN_FilterTypeDef *sFilterConfig)
{
 80135b0:	b480      	push	{r7}
 80135b2:	b085      	sub	sp, #20
 80135b4:	af00      	add	r7, sp, #0
 80135b6:	6078      	str	r0, [r7, #4]
 80135b8:	6039      	str	r1, [r7, #0]
	uint32_t filternbrbitpos;


    /* Initialization mode for the filter */
    CANx->FMR |= CAN_FMR_FINIT;
 80135ba:	687b      	ldr	r3, [r7, #4]
 80135bc:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 80135c0:	f043 0201 	orr.w	r2, r3, #1
 80135c4:	687b      	ldr	r3, [r7, #4]
 80135c6:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200


    /* Convert filter number into bit position */
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 80135ca:	683b      	ldr	r3, [r7, #0]
 80135cc:	68db      	ldr	r3, [r3, #12]
 80135ce:	f003 031f 	and.w	r3, r3, #31
 80135d2:	2201      	movs	r2, #1
 80135d4:	fa02 f303 	lsl.w	r3, r2, r3
 80135d8:	60fb      	str	r3, [r7, #12]

    /* Filter Deactivation */
    CANx->FA1R &= ~(filternbrbitpos);
 80135da:	687b      	ldr	r3, [r7, #4]
 80135dc:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 80135e0:	68fb      	ldr	r3, [r7, #12]
 80135e2:	43db      	mvns	r3, r3
 80135e4:	401a      	ands	r2, r3
 80135e6:	687b      	ldr	r3, [r7, #4]
 80135e8:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c

    /* Filter Scale */


      /* 32-bit scale for the filter */
      CANx->FS1R |= filternbrbitpos;
 80135ec:	687b      	ldr	r3, [r7, #4]
 80135ee:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 80135f2:	68fb      	ldr	r3, [r7, #12]
 80135f4:	431a      	orrs	r2, r3
 80135f6:	687b      	ldr	r3, [r7, #4]
 80135f8:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

      /* Filter Mode */
      if (sFilterConfig->FilterMode == CAN_FILTERMODE_MASK)
 80135fc:	683b      	ldr	r3, [r7, #0]
 80135fe:	691b      	ldr	r3, [r3, #16]
 8013600:	2b00      	cmp	r3, #0
 8013602:	d113      	bne.n	801362c <CAN_ConfigFilter+0x7c>
      {
        /* Id/Mask mode for the filter*/
        CANx->FM1R &= ~(filternbrbitpos);
 8013604:	687b      	ldr	r3, [r7, #4]
 8013606:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 801360a:	68fb      	ldr	r3, [r7, #12]
 801360c:	43db      	mvns	r3, r3
 801360e:	401a      	ands	r2, r3
 8013610:	687b      	ldr	r3, [r7, #4]
 8013612:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

        /* 32-bit identifier  */
        CANx->sFilterRegister[sFilterConfig->FilterBank].FR1 =((uint32_t)sFilterConfig->FilterId) << 21 ;
 8013616:	683b      	ldr	r3, [r7, #0]
 8013618:	681a      	ldr	r2, [r3, #0]
 801361a:	683b      	ldr	r3, [r7, #0]
 801361c:	68db      	ldr	r3, [r3, #12]
 801361e:	0552      	lsls	r2, r2, #21
 8013620:	6879      	ldr	r1, [r7, #4]
 8013622:	3348      	adds	r3, #72	; 0x48
 8013624:	00db      	lsls	r3, r3, #3
 8013626:	440b      	add	r3, r1
 8013628:	605a      	str	r2, [r3, #4]
 801362a:	e010      	b.n	801364e <CAN_ConfigFilter+0x9e>
      }
      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
      {
        /* Identifier list mode for the filter*/
        CANx->FM1R |= (filternbrbitpos);
 801362c:	687b      	ldr	r3, [r7, #4]
 801362e:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8013632:	68fb      	ldr	r3, [r7, #12]
 8013634:	431a      	orrs	r2, r3
 8013636:	687b      	ldr	r3, [r7, #4]
 8013638:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

    	CANx->sFilterRegister[sFilterConfig->FilterBank].FR0 = ((uint32_t)sFilterConfig->FilterMaskId) << 21 ;
 801363c:	683b      	ldr	r3, [r7, #0]
 801363e:	685b      	ldr	r3, [r3, #4]
 8013640:	683a      	ldr	r2, [r7, #0]
 8013642:	68d2      	ldr	r2, [r2, #12]
 8013644:	0559      	lsls	r1, r3, #21
 8013646:	687b      	ldr	r3, [r7, #4]
 8013648:	3248      	adds	r2, #72	; 0x48
 801364a:	f843 1032 	str.w	r1, [r3, r2, lsl #3]

      }

    /* Filter FIFO assignment */
    if (sFilterConfig->FilterFIFOAssignment == CAN_FIFO0)
 801364e:	683b      	ldr	r3, [r7, #0]
 8013650:	689b      	ldr	r3, [r3, #8]
 8013652:	2b00      	cmp	r3, #0
 8013654:	d109      	bne.n	801366a <CAN_ConfigFilter+0xba>
    {
      /* FIFO 0 assignation for the filter */
      CANx->FFA1R &= ~(filternbrbitpos);
 8013656:	687b      	ldr	r3, [r7, #4]
 8013658:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 801365c:	68fb      	ldr	r3, [r7, #12]
 801365e:	43db      	mvns	r3, r3
 8013660:	401a      	ands	r2, r3
 8013662:	687b      	ldr	r3, [r7, #4]
 8013664:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
 8013668:	e007      	b.n	801367a <CAN_ConfigFilter+0xca>
    }
    else
    {
      /* FIFO 1 assignation for the filter */
      CANx->FFA1R |= (filternbrbitpos);
 801366a:	687b      	ldr	r3, [r7, #4]
 801366c:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8013670:	68fb      	ldr	r3, [r7, #12]
 8013672:	431a      	orrs	r2, r3
 8013674:	687b      	ldr	r3, [r7, #4]
 8013676:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    }

    /* Filter activation */
    if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
 801367a:	683b      	ldr	r3, [r7, #0]
 801367c:	695b      	ldr	r3, [r3, #20]
 801367e:	2b00      	cmp	r3, #0
 8013680:	d107      	bne.n	8013692 <CAN_ConfigFilter+0xe2>
    {
      CANx->FA1R |= filternbrbitpos;
 8013682:	687b      	ldr	r3, [r7, #4]
 8013684:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8013688:	68fb      	ldr	r3, [r7, #12]
 801368a:	431a      	orrs	r2, r3
 801368c:	687b      	ldr	r3, [r7, #4]
 801368e:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    }

    /* Leave the initialization mode for the filter */
    CANx->FMR &= ~(CAN_FMR_FINIT);
 8013692:	687b      	ldr	r3, [r7, #4]
 8013694:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 8013698:	f023 0201 	bic.w	r2, r3, #1
 801369c:	687b      	ldr	r3, [r7, #4]
 801369e:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

}
 80136a2:	bf00      	nop
 80136a4:	3714      	adds	r7, #20
 80136a6:	46bd      	mov	sp, r7
 80136a8:	bc80      	pop	{r7}
 80136aa:	4770      	bx	lr

080136ac <FLASH_Unlock>:
/*
 * --------------------  Unlock the FLASH control register access  -----------------------
 *
 */
void FLASH_Unlock(void)
{
 80136ac:	b480      	push	{r7}
 80136ae:	af00      	add	r7, sp, #0

    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 80136b0:	4b04      	ldr	r3, [pc, #16]	; (80136c4 <FLASH_Unlock+0x18>)
 80136b2:	4a05      	ldr	r2, [pc, #20]	; (80136c8 <FLASH_Unlock+0x1c>)
 80136b4:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 80136b6:	4b03      	ldr	r3, [pc, #12]	; (80136c4 <FLASH_Unlock+0x18>)
 80136b8:	4a04      	ldr	r2, [pc, #16]	; (80136cc <FLASH_Unlock+0x20>)
 80136ba:	605a      	str	r2, [r3, #4]
}
 80136bc:	bf00      	nop
 80136be:	46bd      	mov	sp, r7
 80136c0:	bc80      	pop	{r7}
 80136c2:	4770      	bx	lr
 80136c4:	40022000 	.word	0x40022000
 80136c8:	45670123 	.word	0x45670123
 80136cc:	cdef89ab 	.word	0xcdef89ab

080136d0 <FLASH_Lock>:

/**
  *-------------------  Locks the FLASH control register access --------------------------
  */
void FLASH_Lock(void)
{
 80136d0:	b480      	push	{r7}
 80136d2:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 80136d4:	4b04      	ldr	r3, [pc, #16]	; (80136e8 <FLASH_Lock+0x18>)
 80136d6:	691b      	ldr	r3, [r3, #16]
 80136d8:	4a03      	ldr	r2, [pc, #12]	; (80136e8 <FLASH_Lock+0x18>)
 80136da:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80136de:	6113      	str	r3, [r2, #16]

}
 80136e0:	bf00      	nop
 80136e2:	46bd      	mov	sp, r7
 80136e4:	bc80      	pop	{r7}
 80136e6:	4770      	bx	lr
 80136e8:	40022000 	.word	0x40022000

080136ec <FLASH_Program>:
	  }

}

void FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 80136ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80136ee:	b087      	sub	sp, #28
 80136f0:	af00      	add	r7, sp, #0
 80136f2:	60f8      	str	r0, [r7, #12]
 80136f4:	60b9      	str	r1, [r7, #8]
 80136f6:	e9c7 2300 	strd	r2, r3, [r7]
	  uint8_t index = 0;
 80136fa:	2300      	movs	r3, #0
 80136fc:	75fb      	strb	r3, [r7, #23]
	  uint8_t nbiterations = 0;
 80136fe:	2300      	movs	r3, #0
 8013700:	75bb      	strb	r3, [r7, #22]

		/* Wait for busy flag */
		  while (RESET != (FLASH->SR & FLASH_SR_BSY))
 8013702:	bf00      	nop
 8013704:	4b25      	ldr	r3, [pc, #148]	; (801379c <FLASH_Program+0xb0>)
 8013706:	68db      	ldr	r3, [r3, #12]
 8013708:	f003 0301 	and.w	r3, r3, #1
 801370c:	2b00      	cmp	r3, #0
 801370e:	d1f9      	bne.n	8013704 <FLASH_Program+0x18>
		  {
			  /* WAITING */
		  }

		  if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8013710:	68fb      	ldr	r3, [r7, #12]
 8013712:	2b01      	cmp	r3, #1
 8013714:	d102      	bne.n	801371c <FLASH_Program+0x30>
		      {
		        /* Program halfword (16-bit) at a specified address. */
		        nbiterations = 1U;
 8013716:	2301      	movs	r3, #1
 8013718:	75bb      	strb	r3, [r7, #22]
 801371a:	e007      	b.n	801372c <FLASH_Program+0x40>
		      }
		      else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 801371c:	68fb      	ldr	r3, [r7, #12]
 801371e:	2b02      	cmp	r3, #2
 8013720:	d102      	bne.n	8013728 <FLASH_Program+0x3c>
		      {
		        /* Program word (32-bit = 2*16-bit) at a specified address. */
		        nbiterations = 2U;
 8013722:	2302      	movs	r3, #2
 8013724:	75bb      	strb	r3, [r7, #22]
 8013726:	e001      	b.n	801372c <FLASH_Program+0x40>
		      }
		      else
		      {
		        /* Program double word (64-bit = 4*16-bit) at a specified address. */
		        nbiterations = 4U;
 8013728:	2304      	movs	r3, #4
 801372a:	75bb      	strb	r3, [r7, #22]
		      }

		    for (index = 0U; index < nbiterations; index++)
 801372c:	2300      	movs	r3, #0
 801372e:	75fb      	strb	r3, [r7, #23]
 8013730:	e02b      	b.n	801378a <FLASH_Program+0x9e>
		    {
		      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8013732:	7dfb      	ldrb	r3, [r7, #23]
 8013734:	005a      	lsls	r2, r3, #1
 8013736:	68bb      	ldr	r3, [r7, #8]
 8013738:	eb02 0c03 	add.w	ip, r2, r3
 801373c:	7dfb      	ldrb	r3, [r7, #23]
 801373e:	0119      	lsls	r1, r3, #4
 8013740:	e9d7 2300 	ldrd	r2, r3, [r7]
 8013744:	f1c1 0620 	rsb	r6, r1, #32
 8013748:	f1a1 0020 	sub.w	r0, r1, #32
 801374c:	fa22 f401 	lsr.w	r4, r2, r1
 8013750:	fa03 f606 	lsl.w	r6, r3, r6
 8013754:	4334      	orrs	r4, r6
 8013756:	fa23 f000 	lsr.w	r0, r3, r0
 801375a:	4304      	orrs	r4, r0
 801375c:	fa23 f501 	lsr.w	r5, r3, r1
 8013760:	b2a3      	uxth	r3, r4
 8013762:	4619      	mov	r1, r3
 8013764:	4660      	mov	r0, ip
 8013766:	f000 f81b 	bl	80137a0 <FLASH_Program_HalfWord>

				/* Wait for busy flag */
				  while (RESET != (FLASH->SR & FLASH_SR_BSY))
 801376a:	bf00      	nop
 801376c:	4b0b      	ldr	r3, [pc, #44]	; (801379c <FLASH_Program+0xb0>)
 801376e:	68db      	ldr	r3, [r3, #12]
 8013770:	f003 0301 	and.w	r3, r3, #1
 8013774:	2b00      	cmp	r3, #0
 8013776:	d1f9      	bne.n	801376c <FLASH_Program+0x80>
				  {
					  /* WAITING */
				  }

		        /* If the program operation is completed, disable the PG Bit */
				  FLASH->CR &= (~FLASH_CR_PG);
 8013778:	4b08      	ldr	r3, [pc, #32]	; (801379c <FLASH_Program+0xb0>)
 801377a:	691b      	ldr	r3, [r3, #16]
 801377c:	4a07      	ldr	r2, [pc, #28]	; (801379c <FLASH_Program+0xb0>)
 801377e:	f023 0301 	bic.w	r3, r3, #1
 8013782:	6113      	str	r3, [r2, #16]
		    for (index = 0U; index < nbiterations; index++)
 8013784:	7dfb      	ldrb	r3, [r7, #23]
 8013786:	3301      	adds	r3, #1
 8013788:	75fb      	strb	r3, [r7, #23]
 801378a:	7dfa      	ldrb	r2, [r7, #23]
 801378c:	7dbb      	ldrb	r3, [r7, #22]
 801378e:	429a      	cmp	r2, r3
 8013790:	d3cf      	bcc.n	8013732 <FLASH_Program+0x46>
		     }
}
 8013792:	bf00      	nop
 8013794:	bf00      	nop
 8013796:	371c      	adds	r7, #28
 8013798:	46bd      	mov	sp, r7
 801379a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801379c:	40022000 	.word	0x40022000

080137a0 <FLASH_Program_HalfWord>:
  *        Address specify the address to be programmed.
  *        Data    specify the data to be programmed.
  *
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
 80137a0:	b480      	push	{r7}
 80137a2:	b083      	sub	sp, #12
 80137a4:	af00      	add	r7, sp, #0
 80137a6:	6078      	str	r0, [r7, #4]
 80137a8:	460b      	mov	r3, r1
 80137aa:	807b      	strh	r3, [r7, #2]

	/* Proceed to program the new data */
    /* Set Programming Bit */
	FLASH->CR |= FLASH_CR_PG;
 80137ac:	4b06      	ldr	r3, [pc, #24]	; (80137c8 <FLASH_Program_HalfWord+0x28>)
 80137ae:	691b      	ldr	r3, [r3, #16]
 80137b0:	4a05      	ldr	r2, [pc, #20]	; (80137c8 <FLASH_Program_HalfWord+0x28>)
 80137b2:	f043 0301 	orr.w	r3, r3, #1
 80137b6:	6113      	str	r3, [r2, #16]
	  /* Write data in the address */
	  *(volatile uint16_t*)Address = Data;
 80137b8:	687b      	ldr	r3, [r7, #4]
 80137ba:	887a      	ldrh	r2, [r7, #2]
 80137bc:	801a      	strh	r2, [r3, #0]
}
 80137be:	bf00      	nop
 80137c0:	370c      	adds	r7, #12
 80137c2:	46bd      	mov	sp, r7
 80137c4:	bc80      	pop	{r7}
 80137c6:	4770      	bx	lr
 80137c8:	40022000 	.word	0x40022000

080137cc <GPIO_Config_Pin>:
}
void GPIO_Write_Port(GPIO_TypeDef *GPIOx,uint16_t Port_Value){
	GPIOx->ODR = Port_Value;
}

void GPIO_Config_Pin(GPIO_TypeDef *GPIOx, uint8_t Pin_Number, uint8_t Pin_Mode){
 80137cc:	b480      	push	{r7}
 80137ce:	b083      	sub	sp, #12
 80137d0:	af00      	add	r7, sp, #0
 80137d2:	6078      	str	r0, [r7, #4]
 80137d4:	460b      	mov	r3, r1
 80137d6:	70fb      	strb	r3, [r7, #3]
 80137d8:	4613      	mov	r3, r2
 80137da:	70bb      	strb	r3, [r7, #2]
	if(Pin_Number <= GPIO_PIN_7){
 80137dc:	78fb      	ldrb	r3, [r7, #3]
 80137de:	2b07      	cmp	r3, #7
 80137e0:	d815      	bhi.n	801380e <GPIO_Config_Pin+0x42>
		GPIOx->CRL &= ~(0xC << (Pin_Number*4)); //Reset CNF bits
 80137e2:	687b      	ldr	r3, [r7, #4]
 80137e4:	681b      	ldr	r3, [r3, #0]
 80137e6:	78fa      	ldrb	r2, [r7, #3]
 80137e8:	0092      	lsls	r2, r2, #2
 80137ea:	210c      	movs	r1, #12
 80137ec:	fa01 f202 	lsl.w	r2, r1, r2
 80137f0:	43d2      	mvns	r2, r2
 80137f2:	401a      	ands	r2, r3
 80137f4:	687b      	ldr	r3, [r7, #4]
 80137f6:	601a      	str	r2, [r3, #0]
		GPIOx->CRL |= (Pin_Mode << (Pin_Number*4));
 80137f8:	687b      	ldr	r3, [r7, #4]
 80137fa:	681b      	ldr	r3, [r3, #0]
 80137fc:	78b9      	ldrb	r1, [r7, #2]
 80137fe:	78fa      	ldrb	r2, [r7, #3]
 8013800:	0092      	lsls	r2, r2, #2
 8013802:	fa01 f202 	lsl.w	r2, r1, r2
 8013806:	431a      	orrs	r2, r3
 8013808:	687b      	ldr	r3, [r7, #4]
 801380a:	601a      	str	r2, [r3, #0]
		Pin_Number -= 8; //remove bits in CRL
		GPIOx->CRH &= ~(0xC << (Pin_Number*4));
		GPIOx->CRH |= (Pin_Mode << (Pin_Number*4));
	}

}
 801380c:	e01a      	b.n	8013844 <GPIO_Config_Pin+0x78>
	}else if (Pin_Number <= GPIO_PIN_15) {
 801380e:	78fb      	ldrb	r3, [r7, #3]
 8013810:	2b0f      	cmp	r3, #15
 8013812:	d817      	bhi.n	8013844 <GPIO_Config_Pin+0x78>
		Pin_Number -= 8; //remove bits in CRL
 8013814:	78fb      	ldrb	r3, [r7, #3]
 8013816:	3b08      	subs	r3, #8
 8013818:	70fb      	strb	r3, [r7, #3]
		GPIOx->CRH &= ~(0xC << (Pin_Number*4));
 801381a:	687b      	ldr	r3, [r7, #4]
 801381c:	685b      	ldr	r3, [r3, #4]
 801381e:	78fa      	ldrb	r2, [r7, #3]
 8013820:	0092      	lsls	r2, r2, #2
 8013822:	210c      	movs	r1, #12
 8013824:	fa01 f202 	lsl.w	r2, r1, r2
 8013828:	43d2      	mvns	r2, r2
 801382a:	401a      	ands	r2, r3
 801382c:	687b      	ldr	r3, [r7, #4]
 801382e:	605a      	str	r2, [r3, #4]
		GPIOx->CRH |= (Pin_Mode << (Pin_Number*4));
 8013830:	687b      	ldr	r3, [r7, #4]
 8013832:	685b      	ldr	r3, [r3, #4]
 8013834:	78b9      	ldrb	r1, [r7, #2]
 8013836:	78fa      	ldrb	r2, [r7, #3]
 8013838:	0092      	lsls	r2, r2, #2
 801383a:	fa01 f202 	lsl.w	r2, r1, r2
 801383e:	431a      	orrs	r2, r3
 8013840:	687b      	ldr	r3, [r7, #4]
 8013842:	605a      	str	r2, [r3, #4]
}
 8013844:	bf00      	nop
 8013846:	370c      	adds	r7, #12
 8013848:	46bd      	mov	sp, r7
 801384a:	bc80      	pop	{r7}
 801384c:	4770      	bx	lr

0801384e <GPIO_Read_Pin>:

uint8_t GPIO_Read_Pin(GPIO_TypeDef *GPIOx, uint8_t Pin_Number){
 801384e:	b480      	push	{r7}
 8013850:	b083      	sub	sp, #12
 8013852:	af00      	add	r7, sp, #0
 8013854:	6078      	str	r0, [r7, #4]
 8013856:	460b      	mov	r3, r1
 8013858:	70fb      	strb	r3, [r7, #3]
	return (((GPIOx->IDR) >> Pin_Number) & 0x1);
 801385a:	687b      	ldr	r3, [r7, #4]
 801385c:	689a      	ldr	r2, [r3, #8]
 801385e:	78fb      	ldrb	r3, [r7, #3]
 8013860:	fa22 f303 	lsr.w	r3, r2, r3
 8013864:	b2db      	uxtb	r3, r3
 8013866:	f003 0301 	and.w	r3, r3, #1
 801386a:	b2db      	uxtb	r3, r3
}
 801386c:	4618      	mov	r0, r3
 801386e:	370c      	adds	r7, #12
 8013870:	46bd      	mov	sp, r7
 8013872:	bc80      	pop	{r7}
 8013874:	4770      	bx	lr

08013876 <GPIO_Write_Pin>:
void GPIO_Write_Pin(GPIO_TypeDef *GPIOx, uint8_t Pin_Number, uint8_t Value){
 8013876:	b480      	push	{r7}
 8013878:	b083      	sub	sp, #12
 801387a:	af00      	add	r7, sp, #0
 801387c:	6078      	str	r0, [r7, #4]
 801387e:	460b      	mov	r3, r1
 8013880:	70fb      	strb	r3, [r7, #3]
 8013882:	4613      	mov	r3, r2
 8013884:	70bb      	strb	r3, [r7, #2]
	if(Value == HIGH){
 8013886:	78bb      	ldrb	r3, [r7, #2]
 8013888:	2b01      	cmp	r3, #1
 801388a:	d109      	bne.n	80138a0 <GPIO_Write_Pin+0x2a>
		GPIOx->BSRR |= (0x1 << Pin_Number);
 801388c:	687b      	ldr	r3, [r7, #4]
 801388e:	691b      	ldr	r3, [r3, #16]
 8013890:	78fa      	ldrb	r2, [r7, #3]
 8013892:	2101      	movs	r1, #1
 8013894:	fa01 f202 	lsl.w	r2, r1, r2
 8013898:	431a      	orrs	r2, r3
 801389a:	687b      	ldr	r3, [r7, #4]
 801389c:	611a      	str	r2, [r3, #16]
	}else if(Value == LOW){
		GPIOx->BSRR |= (0x1 << (Pin_Number + 16));
	}
}
 801389e:	e00c      	b.n	80138ba <GPIO_Write_Pin+0x44>
	}else if(Value == LOW){
 80138a0:	78bb      	ldrb	r3, [r7, #2]
 80138a2:	2b00      	cmp	r3, #0
 80138a4:	d109      	bne.n	80138ba <GPIO_Write_Pin+0x44>
		GPIOx->BSRR |= (0x1 << (Pin_Number + 16));
 80138a6:	687b      	ldr	r3, [r7, #4]
 80138a8:	691b      	ldr	r3, [r3, #16]
 80138aa:	78fa      	ldrb	r2, [r7, #3]
 80138ac:	3210      	adds	r2, #16
 80138ae:	2101      	movs	r1, #1
 80138b0:	fa01 f202 	lsl.w	r2, r1, r2
 80138b4:	431a      	orrs	r2, r3
 80138b6:	687b      	ldr	r3, [r7, #4]
 80138b8:	611a      	str	r2, [r3, #16]
}
 80138ba:	bf00      	nop
 80138bc:	370c      	adds	r7, #12
 80138be:	46bd      	mov	sp, r7
 80138c0:	bc80      	pop	{r7}
 80138c2:	4770      	bx	lr

080138c4 <Enable_irq>:
  \brief   Enable IRQ Interrupts
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
void Enable_irq(void)
{
 80138c4:	b480      	push	{r7}
 80138c6:	af00      	add	r7, sp, #0
	__asm volatile ("cpsie i" : : : "memory");
 80138c8:	b662      	cpsie	i
}
 80138ca:	bf00      	nop
 80138cc:	46bd      	mov	sp, r7
 80138ce:	bc80      	pop	{r7}
 80138d0:	4770      	bx	lr

080138d2 <Disable_irq>:
  \brief   Disable IRQ Interrupts
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
void Disable_irq(void)
{
 80138d2:	b480      	push	{r7}
 80138d4:	af00      	add	r7, sp, #0
	__asm volatile ("cpsid i" : : : "memory");
 80138d6:	b672      	cpsid	i
}
 80138d8:	bf00      	nop
 80138da:	46bd      	mov	sp, r7
 80138dc:	bc80      	pop	{r7}
 80138de:	4770      	bx	lr

080138e0 <NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
void NVIC_EnableIRQ(NVIC_IRQn_Type IRQn)
{
 80138e0:	b480      	push	{r7}
 80138e2:	b083      	sub	sp, #12
 80138e4:	af00      	add	r7, sp, #0
 80138e6:	4603      	mov	r3, r0
 80138e8:	71fb      	strb	r3, [r7, #7]

    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80138ea:	79fb      	ldrb	r3, [r7, #7]
 80138ec:	f003 031f 	and.w	r3, r3, #31
 80138f0:	4907      	ldr	r1, [pc, #28]	; (8013910 <NVIC_EnableIRQ+0x30>)
 80138f2:	79fa      	ldrb	r2, [r7, #7]
 80138f4:	0952      	lsrs	r2, r2, #5
 80138f6:	b2d2      	uxtb	r2, r2
 80138f8:	4610      	mov	r0, r2
 80138fa:	2201      	movs	r2, #1
 80138fc:	fa02 f303 	lsl.w	r3, r2, r3
 8013900:	f841 3020 	str.w	r3, [r1, r0, lsl #2]

}
 8013904:	bf00      	nop
 8013906:	370c      	adds	r7, #12
 8013908:	46bd      	mov	sp, r7
 801390a:	bc80      	pop	{r7}
 801390c:	4770      	bx	lr
 801390e:	bf00      	nop
 8013910:	e000e100 	.word	0xe000e100

08013914 <NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
void NVIC_ClearPendingIRQ(NVIC_IRQn_Type IRQn)
{
 8013914:	b480      	push	{r7}
 8013916:	b083      	sub	sp, #12
 8013918:	af00      	add	r7, sp, #0
 801391a:	4603      	mov	r3, r0
 801391c:	71fb      	strb	r3, [r7, #7]

    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 801391e:	79fb      	ldrb	r3, [r7, #7]
 8013920:	f003 031f 	and.w	r3, r3, #31
 8013924:	4907      	ldr	r1, [pc, #28]	; (8013944 <NVIC_ClearPendingIRQ+0x30>)
 8013926:	79fa      	ldrb	r2, [r7, #7]
 8013928:	0952      	lsrs	r2, r2, #5
 801392a:	b2d2      	uxtb	r2, r2
 801392c:	4610      	mov	r0, r2
 801392e:	2201      	movs	r2, #1
 8013930:	409a      	lsls	r2, r3
 8013932:	f100 0360 	add.w	r3, r0, #96	; 0x60
 8013936:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

}
 801393a:	bf00      	nop
 801393c:	370c      	adds	r7, #12
 801393e:	46bd      	mov	sp, r7
 8013940:	bc80      	pop	{r7}
 8013942:	4770      	bx	lr
 8013944:	e000e100 	.word	0xe000e100

08013948 <RCC_Config>:
 */
#include "RCC.h"
#include "RCC_Config.h"


void RCC_Config(void){
 8013948:	b480      	push	{r7}
 801394a:	af00      	add	r7, sp, #0
	//Enable Flash Prefetch
	FLASH->ACR |= FLASH_ACR_PRFTBE;
 801394c:	4b38      	ldr	r3, [pc, #224]	; (8013a30 <RCC_Config+0xe8>)
 801394e:	681b      	ldr	r3, [r3, #0]
 8013950:	4a37      	ldr	r2, [pc, #220]	; (8013a30 <RCC_Config+0xe8>)
 8013952:	f043 0310 	orr.w	r3, r3, #16
 8013956:	6013      	str	r3, [r2, #0]
	//Clock security system Disable
	RCC->CR &= ~(RCC_CR_CSSON_Msk);
 8013958:	4b36      	ldr	r3, [pc, #216]	; (8013a34 <RCC_Config+0xec>)
 801395a:	681b      	ldr	r3, [r3, #0]
 801395c:	4a35      	ldr	r2, [pc, #212]	; (8013a34 <RCC_Config+0xec>)
 801395e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8013962:	6013      	str	r3, [r2, #0]
	//Clear All bits
	RCC->CR &= 0x0;
 8013964:	4b33      	ldr	r3, [pc, #204]	; (8013a34 <RCC_Config+0xec>)
 8013966:	681b      	ldr	r3, [r3, #0]
 8013968:	4b32      	ldr	r3, [pc, #200]	; (8013a34 <RCC_Config+0xec>)
 801396a:	2200      	movs	r2, #0
 801396c:	601a      	str	r2, [r3, #0]
	RCC->CFGR &= 0x0;
 801396e:	4b31      	ldr	r3, [pc, #196]	; (8013a34 <RCC_Config+0xec>)
 8013970:	685b      	ldr	r3, [r3, #4]
 8013972:	4b30      	ldr	r3, [pc, #192]	; (8013a34 <RCC_Config+0xec>)
 8013974:	2200      	movs	r2, #0
 8013976:	605a      	str	r2, [r3, #4]
	//reset all interrupts
	RCC->CIR = 0x0;
 8013978:	4b2e      	ldr	r3, [pc, #184]	; (8013a34 <RCC_Config+0xec>)
 801397a:	2200      	movs	r2, #0
 801397c:	609a      	str	r2, [r3, #8]
	//enable HSI (ensure)
	RCC->CR |= RCC_CR_HSION;
 801397e:	4b2d      	ldr	r3, [pc, #180]	; (8013a34 <RCC_Config+0xec>)
 8013980:	681b      	ldr	r3, [r3, #0]
 8013982:	4a2c      	ldr	r2, [pc, #176]	; (8013a34 <RCC_Config+0xec>)
 8013984:	f043 0301 	orr.w	r3, r3, #1
 8013988:	6013      	str	r3, [r2, #0]
	while(!(RCC->CR & RCC_CR_HSIRDY));
 801398a:	bf00      	nop
 801398c:	4b29      	ldr	r3, [pc, #164]	; (8013a34 <RCC_Config+0xec>)
 801398e:	681b      	ldr	r3, [r3, #0]
 8013990:	f003 0302 	and.w	r3, r3, #2
 8013994:	2b00      	cmp	r3, #0
 8013996:	d0f9      	beq.n	801398c <RCC_Config+0x44>

#ifdef RCC_HSE_NO
	//enable HSE
	RCC->CR |= RCC_CR_HSEON;
 8013998:	4b26      	ldr	r3, [pc, #152]	; (8013a34 <RCC_Config+0xec>)
 801399a:	681b      	ldr	r3, [r3, #0]
 801399c:	4a25      	ldr	r2, [pc, #148]	; (8013a34 <RCC_Config+0xec>)
 801399e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80139a2:	6013      	str	r3, [r2, #0]
	while(!(RCC->CR & RCC_CR_HSERDY));
 80139a4:	bf00      	nop
 80139a6:	4b23      	ldr	r3, [pc, #140]	; (8013a34 <RCC_Config+0xec>)
 80139a8:	681b      	ldr	r3, [r3, #0]
 80139aa:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80139ae:	2b00      	cmp	r3, #0
 80139b0:	d0f9      	beq.n	80139a6 <RCC_Config+0x5e>
	RCC->CFGR |= RCC_CFGR_PLLSRC;
 80139b2:	4b20      	ldr	r3, [pc, #128]	; (8013a34 <RCC_Config+0xec>)
 80139b4:	685b      	ldr	r3, [r3, #4]
 80139b6:	4a1f      	ldr	r2, [pc, #124]	; (8013a34 <RCC_Config+0xec>)
 80139b8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80139bc:	6053      	str	r3, [r2, #4]
//



#ifdef RCC_AHB_PRESCALE
	RCC->CFGR |= RCC_AHB_PRESCALE;
 80139be:	4b1d      	ldr	r3, [pc, #116]	; (8013a34 <RCC_Config+0xec>)
 80139c0:	4a1c      	ldr	r2, [pc, #112]	; (8013a34 <RCC_Config+0xec>)
 80139c2:	685b      	ldr	r3, [r3, #4]
 80139c4:	6053      	str	r3, [r2, #4]
#endif
#ifdef RCC_APB1_PRESCALE
	RCC->CFGR |= RCC_APB1_PRESCALE;
 80139c6:	4b1b      	ldr	r3, [pc, #108]	; (8013a34 <RCC_Config+0xec>)
 80139c8:	685b      	ldr	r3, [r3, #4]
 80139ca:	4a1a      	ldr	r2, [pc, #104]	; (8013a34 <RCC_Config+0xec>)
 80139cc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80139d0:	6053      	str	r3, [r2, #4]
#endif
#ifdef RCC_APB2_PRESCALE
	RCC->CFGR |= RCC_APB2_PRESCALE;
 80139d2:	4b18      	ldr	r3, [pc, #96]	; (8013a34 <RCC_Config+0xec>)
 80139d4:	4a17      	ldr	r2, [pc, #92]	; (8013a34 <RCC_Config+0xec>)
 80139d6:	685b      	ldr	r3, [r3, #4]
 80139d8:	6053      	str	r3, [r2, #4]
#endif

#ifdef RCC_SYSCLK
	//Configure Flash Letancy (2 Wait states)
	FLASH->ACR |= FLASH_ACR_LATENCY_1;
 80139da:	4b15      	ldr	r3, [pc, #84]	; (8013a30 <RCC_Config+0xe8>)
 80139dc:	681b      	ldr	r3, [r3, #0]
 80139de:	4a14      	ldr	r2, [pc, #80]	; (8013a30 <RCC_Config+0xe8>)
 80139e0:	f043 0302 	orr.w	r3, r3, #2
 80139e4:	6013      	str	r3, [r2, #0]
	RCC->CFGR |= RCC_PLL_MUL;
 80139e6:	4b13      	ldr	r3, [pc, #76]	; (8013a34 <RCC_Config+0xec>)
 80139e8:	685b      	ldr	r3, [r3, #4]
 80139ea:	4a12      	ldr	r2, [pc, #72]	; (8013a34 <RCC_Config+0xec>)
 80139ec:	f443 13e0 	orr.w	r3, r3, #1835008	; 0x1c0000
 80139f0:	6053      	str	r3, [r2, #4]
	RCC->CR |= RCC_CR_PLLON;
 80139f2:	4b10      	ldr	r3, [pc, #64]	; (8013a34 <RCC_Config+0xec>)
 80139f4:	681b      	ldr	r3, [r3, #0]
 80139f6:	4a0f      	ldr	r2, [pc, #60]	; (8013a34 <RCC_Config+0xec>)
 80139f8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80139fc:	6013      	str	r3, [r2, #0]
	while(!(RCC->CR & RCC_CR_PLLRDY));
 80139fe:	bf00      	nop
 8013a00:	4b0c      	ldr	r3, [pc, #48]	; (8013a34 <RCC_Config+0xec>)
 8013a02:	681b      	ldr	r3, [r3, #0]
 8013a04:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8013a08:	2b00      	cmp	r3, #0
 8013a0a:	d0f9      	beq.n	8013a00 <RCC_Config+0xb8>
	//Sysclk Selection
	RCC->CFGR |= RCC_CFGR_SW_PLL;
 8013a0c:	4b09      	ldr	r3, [pc, #36]	; (8013a34 <RCC_Config+0xec>)
 8013a0e:	685b      	ldr	r3, [r3, #4]
 8013a10:	4a08      	ldr	r2, [pc, #32]	; (8013a34 <RCC_Config+0xec>)
 8013a12:	f043 0302 	orr.w	r3, r3, #2
 8013a16:	6053      	str	r3, [r2, #4]
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));
 8013a18:	bf00      	nop
 8013a1a:	4b06      	ldr	r3, [pc, #24]	; (8013a34 <RCC_Config+0xec>)
 8013a1c:	685b      	ldr	r3, [r3, #4]
 8013a1e:	f003 0308 	and.w	r3, r3, #8
 8013a22:	2b00      	cmp	r3, #0
 8013a24:	d0f9      	beq.n	8013a1a <RCC_Config+0xd2>
#endif
}
 8013a26:	bf00      	nop
 8013a28:	bf00      	nop
 8013a2a:	46bd      	mov	sp, r7
 8013a2c:	bc80      	pop	{r7}
 8013a2e:	4770      	bx	lr
 8013a30:	40022000 	.word	0x40022000
 8013a34:	40021000 	.word	0x40021000

08013a38 <RCC_EnablePeripheral>:

void RCC_EnablePeripheral(uint8_t peripheralNumber){
 8013a38:	b480      	push	{r7}
 8013a3a:	b083      	sub	sp, #12
 8013a3c:	af00      	add	r7, sp, #0
 8013a3e:	4603      	mov	r3, r0
 8013a40:	71fb      	strb	r3, [r7, #7]
	if(peripheralNumber <= APB2_END){
 8013a42:	79fb      	ldrb	r3, [r7, #7]
 8013a44:	2b1f      	cmp	r3, #31
 8013a46:	d80a      	bhi.n	8013a5e <RCC_EnablePeripheral+0x26>
		RCC->APB2ENR |= (1 << peripheralNumber);
 8013a48:	4b1b      	ldr	r3, [pc, #108]	; (8013ab8 <RCC_EnablePeripheral+0x80>)
 8013a4a:	699b      	ldr	r3, [r3, #24]
 8013a4c:	79fa      	ldrb	r2, [r7, #7]
 8013a4e:	2101      	movs	r1, #1
 8013a50:	fa01 f202 	lsl.w	r2, r1, r2
 8013a54:	4611      	mov	r1, r2
 8013a56:	4a18      	ldr	r2, [pc, #96]	; (8013ab8 <RCC_EnablePeripheral+0x80>)
 8013a58:	430b      	orrs	r3, r1
 8013a5a:	6193      	str	r3, [r2, #24]
		peripheralNumber -= AHB_START;
		RCC->AHBENR |= (1 << peripheralNumber);
	}else{
		//Do nothing
	}
}
 8013a5c:	e026      	b.n	8013aac <RCC_EnablePeripheral+0x74>
	}else if((peripheralNumber >= APB1_START) && (peripheralNumber <= APB1_END)){
 8013a5e:	79fb      	ldrb	r3, [r7, #7]
 8013a60:	2b1f      	cmp	r3, #31
 8013a62:	d910      	bls.n	8013a86 <RCC_EnablePeripheral+0x4e>
 8013a64:	79fb      	ldrb	r3, [r7, #7]
 8013a66:	2b3f      	cmp	r3, #63	; 0x3f
 8013a68:	d80d      	bhi.n	8013a86 <RCC_EnablePeripheral+0x4e>
		peripheralNumber -= APB1_START;
 8013a6a:	79fb      	ldrb	r3, [r7, #7]
 8013a6c:	3b20      	subs	r3, #32
 8013a6e:	71fb      	strb	r3, [r7, #7]
		RCC->APB1ENR |= (1 << peripheralNumber);
 8013a70:	4b11      	ldr	r3, [pc, #68]	; (8013ab8 <RCC_EnablePeripheral+0x80>)
 8013a72:	69db      	ldr	r3, [r3, #28]
 8013a74:	79fa      	ldrb	r2, [r7, #7]
 8013a76:	2101      	movs	r1, #1
 8013a78:	fa01 f202 	lsl.w	r2, r1, r2
 8013a7c:	4611      	mov	r1, r2
 8013a7e:	4a0e      	ldr	r2, [pc, #56]	; (8013ab8 <RCC_EnablePeripheral+0x80>)
 8013a80:	430b      	orrs	r3, r1
 8013a82:	61d3      	str	r3, [r2, #28]
}
 8013a84:	e012      	b.n	8013aac <RCC_EnablePeripheral+0x74>
	}else if((peripheralNumber >= AHB_START) && (peripheralNumber <= AHB_END)){
 8013a86:	79fb      	ldrb	r3, [r7, #7]
 8013a88:	2b3f      	cmp	r3, #63	; 0x3f
 8013a8a:	d90f      	bls.n	8013aac <RCC_EnablePeripheral+0x74>
 8013a8c:	79fb      	ldrb	r3, [r7, #7]
 8013a8e:	2b5f      	cmp	r3, #95	; 0x5f
 8013a90:	d80c      	bhi.n	8013aac <RCC_EnablePeripheral+0x74>
		peripheralNumber -= AHB_START;
 8013a92:	79fb      	ldrb	r3, [r7, #7]
 8013a94:	3b40      	subs	r3, #64	; 0x40
 8013a96:	71fb      	strb	r3, [r7, #7]
		RCC->AHBENR |= (1 << peripheralNumber);
 8013a98:	4b07      	ldr	r3, [pc, #28]	; (8013ab8 <RCC_EnablePeripheral+0x80>)
 8013a9a:	695b      	ldr	r3, [r3, #20]
 8013a9c:	79fa      	ldrb	r2, [r7, #7]
 8013a9e:	2101      	movs	r1, #1
 8013aa0:	fa01 f202 	lsl.w	r2, r1, r2
 8013aa4:	4611      	mov	r1, r2
 8013aa6:	4a04      	ldr	r2, [pc, #16]	; (8013ab8 <RCC_EnablePeripheral+0x80>)
 8013aa8:	430b      	orrs	r3, r1
 8013aaa:	6153      	str	r3, [r2, #20]
}
 8013aac:	bf00      	nop
 8013aae:	370c      	adds	r7, #12
 8013ab0:	46bd      	mov	sp, r7
 8013ab2:	bc80      	pop	{r7}
 8013ab4:	4770      	bx	lr
 8013ab6:	bf00      	nop
 8013ab8:	40021000 	.word	0x40021000

08013abc <RCC_DisablePeripheral>:

void RCC_DisablePeripheral(uint8_t peripheralNumber){
 8013abc:	b480      	push	{r7}
 8013abe:	b083      	sub	sp, #12
 8013ac0:	af00      	add	r7, sp, #0
 8013ac2:	4603      	mov	r3, r0
 8013ac4:	71fb      	strb	r3, [r7, #7]
	if(peripheralNumber <= APB2_END){
 8013ac6:	79fb      	ldrb	r3, [r7, #7]
 8013ac8:	2b1f      	cmp	r3, #31
 8013aca:	d80b      	bhi.n	8013ae4 <RCC_DisablePeripheral+0x28>
		RCC->APB2ENR &= ~((1 << peripheralNumber));
 8013acc:	4b1c      	ldr	r3, [pc, #112]	; (8013b40 <RCC_DisablePeripheral+0x84>)
 8013ace:	699b      	ldr	r3, [r3, #24]
 8013ad0:	79fa      	ldrb	r2, [r7, #7]
 8013ad2:	2101      	movs	r1, #1
 8013ad4:	fa01 f202 	lsl.w	r2, r1, r2
 8013ad8:	43d2      	mvns	r2, r2
 8013ada:	4611      	mov	r1, r2
 8013adc:	4a18      	ldr	r2, [pc, #96]	; (8013b40 <RCC_DisablePeripheral+0x84>)
 8013ade:	400b      	ands	r3, r1
 8013ae0:	6193      	str	r3, [r2, #24]
		peripheralNumber -= AHB_START;
		RCC->AHBENR &= ~((1 << peripheralNumber));
	}else{
		//Do nothing
	}
}
 8013ae2:	e028      	b.n	8013b36 <RCC_DisablePeripheral+0x7a>
	}else if((peripheralNumber >= APB1_START) && (peripheralNumber <= APB1_END)){
 8013ae4:	79fb      	ldrb	r3, [r7, #7]
 8013ae6:	2b1f      	cmp	r3, #31
 8013ae8:	d911      	bls.n	8013b0e <RCC_DisablePeripheral+0x52>
 8013aea:	79fb      	ldrb	r3, [r7, #7]
 8013aec:	2b3f      	cmp	r3, #63	; 0x3f
 8013aee:	d80e      	bhi.n	8013b0e <RCC_DisablePeripheral+0x52>
		peripheralNumber -= APB1_START;
 8013af0:	79fb      	ldrb	r3, [r7, #7]
 8013af2:	3b20      	subs	r3, #32
 8013af4:	71fb      	strb	r3, [r7, #7]
		RCC->APB1ENR &= ~((1 << peripheralNumber));
 8013af6:	4b12      	ldr	r3, [pc, #72]	; (8013b40 <RCC_DisablePeripheral+0x84>)
 8013af8:	69db      	ldr	r3, [r3, #28]
 8013afa:	79fa      	ldrb	r2, [r7, #7]
 8013afc:	2101      	movs	r1, #1
 8013afe:	fa01 f202 	lsl.w	r2, r1, r2
 8013b02:	43d2      	mvns	r2, r2
 8013b04:	4611      	mov	r1, r2
 8013b06:	4a0e      	ldr	r2, [pc, #56]	; (8013b40 <RCC_DisablePeripheral+0x84>)
 8013b08:	400b      	ands	r3, r1
 8013b0a:	61d3      	str	r3, [r2, #28]
}
 8013b0c:	e013      	b.n	8013b36 <RCC_DisablePeripheral+0x7a>
	}else if((peripheralNumber >= AHB_START) && (peripheralNumber <= AHB_END)){
 8013b0e:	79fb      	ldrb	r3, [r7, #7]
 8013b10:	2b3f      	cmp	r3, #63	; 0x3f
 8013b12:	d910      	bls.n	8013b36 <RCC_DisablePeripheral+0x7a>
 8013b14:	79fb      	ldrb	r3, [r7, #7]
 8013b16:	2b5f      	cmp	r3, #95	; 0x5f
 8013b18:	d80d      	bhi.n	8013b36 <RCC_DisablePeripheral+0x7a>
		peripheralNumber -= AHB_START;
 8013b1a:	79fb      	ldrb	r3, [r7, #7]
 8013b1c:	3b40      	subs	r3, #64	; 0x40
 8013b1e:	71fb      	strb	r3, [r7, #7]
		RCC->AHBENR &= ~((1 << peripheralNumber));
 8013b20:	4b07      	ldr	r3, [pc, #28]	; (8013b40 <RCC_DisablePeripheral+0x84>)
 8013b22:	695b      	ldr	r3, [r3, #20]
 8013b24:	79fa      	ldrb	r2, [r7, #7]
 8013b26:	2101      	movs	r1, #1
 8013b28:	fa01 f202 	lsl.w	r2, r1, r2
 8013b2c:	43d2      	mvns	r2, r2
 8013b2e:	4611      	mov	r1, r2
 8013b30:	4a03      	ldr	r2, [pc, #12]	; (8013b40 <RCC_DisablePeripheral+0x84>)
 8013b32:	400b      	ands	r3, r1
 8013b34:	6153      	str	r3, [r2, #20]
}
 8013b36:	bf00      	nop
 8013b38:	370c      	adds	r7, #12
 8013b3a:	46bd      	mov	sp, r7
 8013b3c:	bc80      	pop	{r7}
 8013b3e:	4770      	bx	lr
 8013b40:	40021000 	.word	0x40021000

08013b44 <SCB_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
void SCB_SetPriority(SCB_IRQn_Type IRQn, uint32_t priority)
{
 8013b44:	b480      	push	{r7}
 8013b46:	b083      	sub	sp, #12
 8013b48:	af00      	add	r7, sp, #0
 8013b4a:	4603      	mov	r3, r0
 8013b4c:	6039      	str	r1, [r7, #0]
 8013b4e:	71fb      	strb	r3, [r7, #7]

    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - SCB_PRIO_BITS)) & (uint32_t)0xFFUL);
 8013b50:	683b      	ldr	r3, [r7, #0]
 8013b52:	b2da      	uxtb	r2, r3
 8013b54:	4906      	ldr	r1, [pc, #24]	; (8013b70 <SCB_SetPriority+0x2c>)
 8013b56:	79fb      	ldrb	r3, [r7, #7]
 8013b58:	f003 030f 	and.w	r3, r3, #15
 8013b5c:	3b04      	subs	r3, #4
 8013b5e:	0112      	lsls	r2, r2, #4
 8013b60:	b2d2      	uxtb	r2, r2
 8013b62:	440b      	add	r3, r1
 8013b64:	761a      	strb	r2, [r3, #24]

}
 8013b66:	bf00      	nop
 8013b68:	370c      	adds	r7, #12
 8013b6a:	46bd      	mov	sp, r7
 8013b6c:	bc80      	pop	{r7}
 8013b6e:	4770      	bx	lr
 8013b70:	e000ed00 	.word	0xe000ed00

08013b74 <SysTick_INIT>:
           must contain a vendor-specific implementation of this function.
 */

volatile uint32_t ticks;
void SysTick_INIT(void)
{
 8013b74:	b580      	push	{r7, lr}
 8013b76:	af00      	add	r7, sp, #0

  SysTick->LOAD  = (uint32_t)(SYSTEMCLOCK/1000 - 1UL);                         /* set reload register */
 8013b78:	4b07      	ldr	r3, [pc, #28]	; (8013b98 <SysTick_INIT+0x24>)
 8013b7a:	4a08      	ldr	r2, [pc, #32]	; (8013b9c <SysTick_INIT+0x28>)
 8013b7c:	605a      	str	r2, [r3, #4]
  SCB_SetPriority (SysTick_IRQn, (1UL << SCB_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8013b7e:	210f      	movs	r1, #15
 8013b80:	f04f 30ff 	mov.w	r0, #4294967295
 8013b84:	f7ff ffde 	bl	8013b44 <SCB_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8013b88:	4b03      	ldr	r3, [pc, #12]	; (8013b98 <SysTick_INIT+0x24>)
 8013b8a:	2200      	movs	r2, #0
 8013b8c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8013b8e:	4b02      	ldr	r3, [pc, #8]	; (8013b98 <SysTick_INIT+0x24>)
 8013b90:	2207      	movs	r2, #7
 8013b92:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */                                                    /* Function successful */
}
 8013b94:	bf00      	nop
 8013b96:	bd80      	pop	{r7, pc}
 8013b98:	e000e010 	.word	0xe000e010
 8013b9c:	0001193f 	.word	0x0001193f

08013ba0 <SysTick_Delay>:

void SysTick_Delay(uint32_t delay_ms){
 8013ba0:	b480      	push	{r7}
 8013ba2:	b085      	sub	sp, #20
 8013ba4:	af00      	add	r7, sp, #0
 8013ba6:	6078      	str	r0, [r7, #4]
	uint32_t tickstart = ticks;
 8013ba8:	4b0a      	ldr	r3, [pc, #40]	; (8013bd4 <SysTick_Delay+0x34>)
 8013baa:	681b      	ldr	r3, [r3, #0]
 8013bac:	60fb      	str	r3, [r7, #12]
	uint32_t wait = delay_ms;
 8013bae:	687b      	ldr	r3, [r7, #4]
 8013bb0:	60bb      	str	r3, [r7, #8]

	/* Add a freq to guarantee minimum wait */
	wait += 1;
 8013bb2:	68bb      	ldr	r3, [r7, #8]
 8013bb4:	3301      	adds	r3, #1
 8013bb6:	60bb      	str	r3, [r7, #8]

	while ((ticks - tickstart) < wait) {
 8013bb8:	bf00      	nop
 8013bba:	4b06      	ldr	r3, [pc, #24]	; (8013bd4 <SysTick_Delay+0x34>)
 8013bbc:	681a      	ldr	r2, [r3, #0]
 8013bbe:	68fb      	ldr	r3, [r7, #12]
 8013bc0:	1ad3      	subs	r3, r2, r3
 8013bc2:	68ba      	ldr	r2, [r7, #8]
 8013bc4:	429a      	cmp	r2, r3
 8013bc6:	d8f8      	bhi.n	8013bba <SysTick_Delay+0x1a>
	}
}
 8013bc8:	bf00      	nop
 8013bca:	bf00      	nop
 8013bcc:	3714      	adds	r7, #20
 8013bce:	46bd      	mov	sp, r7
 8013bd0:	bc80      	pop	{r7}
 8013bd2:	4770      	bx	lr
 8013bd4:	20000108 	.word	0x20000108

08013bd8 <SysTick_GetTicks>:
{
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~(SysTick_CTRL_TICKINT_Msk);
}

uint32_t SysTick_GetTicks(void){
 8013bd8:	b480      	push	{r7}
 8013bda:	af00      	add	r7, sp, #0
	return ticks;
 8013bdc:	4b02      	ldr	r3, [pc, #8]	; (8013be8 <SysTick_GetTicks+0x10>)
 8013bde:	681b      	ldr	r3, [r3, #0]
}
 8013be0:	4618      	mov	r0, r3
 8013be2:	46bd      	mov	sp, r7
 8013be4:	bc80      	pop	{r7}
 8013be6:	4770      	bx	lr
 8013be8:	20000108 	.word	0x20000108

08013bec <TIM_Base_SetConfig>:
#include "TIM.h"

/*
 * Available Timers -> TIM1, TIM2, TIM3, TIM4
 */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Config) {
 8013bec:	b480      	push	{r7}
 8013bee:	b083      	sub	sp, #12
 8013bf0:	af00      	add	r7, sp, #0
 8013bf2:	6078      	str	r0, [r7, #4]
 8013bf4:	6039      	str	r1, [r7, #0]
	TIMx->CR1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8013bf6:	687b      	ldr	r3, [r7, #4]
 8013bf8:	681b      	ldr	r3, [r3, #0]
 8013bfa:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8013bfe:	687b      	ldr	r3, [r7, #4]
 8013c00:	601a      	str	r2, [r3, #0]
	TIMx->CR1 |= Config->CounterMode;
 8013c02:	687b      	ldr	r3, [r7, #4]
 8013c04:	681a      	ldr	r2, [r3, #0]
 8013c06:	683b      	ldr	r3, [r7, #0]
 8013c08:	685b      	ldr	r3, [r3, #4]
 8013c0a:	431a      	orrs	r2, r3
 8013c0c:	687b      	ldr	r3, [r7, #4]
 8013c0e:	601a      	str	r2, [r3, #0]
	TIMx->CR1 &= ~TIM_CR1_CKD;
 8013c10:	687b      	ldr	r3, [r7, #4]
 8013c12:	681b      	ldr	r3, [r3, #0]
 8013c14:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8013c18:	687b      	ldr	r3, [r7, #4]
 8013c1a:	601a      	str	r2, [r3, #0]
	TIMx->CR1 |= (uint32_t) Config->ClockDivision;
 8013c1c:	687b      	ldr	r3, [r7, #4]
 8013c1e:	681a      	ldr	r2, [r3, #0]
 8013c20:	683b      	ldr	r3, [r7, #0]
 8013c22:	68db      	ldr	r3, [r3, #12]
 8013c24:	431a      	orrs	r2, r3
 8013c26:	687b      	ldr	r3, [r7, #4]
 8013c28:	601a      	str	r2, [r3, #0]
	TIMx->CR1 &= TIM_CR1_ARPE;
 8013c2a:	687b      	ldr	r3, [r7, #4]
 8013c2c:	681b      	ldr	r3, [r3, #0]
 8013c2e:	f003 0280 	and.w	r2, r3, #128	; 0x80
 8013c32:	687b      	ldr	r3, [r7, #4]
 8013c34:	601a      	str	r2, [r3, #0]
	TIMx->CR1 |= Config->AutoReloadPreload;
 8013c36:	687b      	ldr	r3, [r7, #4]
 8013c38:	681a      	ldr	r2, [r3, #0]
 8013c3a:	683b      	ldr	r3, [r7, #0]
 8013c3c:	695b      	ldr	r3, [r3, #20]
 8013c3e:	431a      	orrs	r2, r3
 8013c40:	687b      	ldr	r3, [r7, #4]
 8013c42:	601a      	str	r2, [r3, #0]
	TIMx->ARR = (uint32_t) Config->Period;
 8013c44:	683b      	ldr	r3, [r7, #0]
 8013c46:	689a      	ldr	r2, [r3, #8]
 8013c48:	687b      	ldr	r3, [r7, #4]
 8013c4a:	62da      	str	r2, [r3, #44]	; 0x2c
	TIMx->PSC = Config->Prescaler;
 8013c4c:	683b      	ldr	r3, [r7, #0]
 8013c4e:	681a      	ldr	r2, [r3, #0]
 8013c50:	687b      	ldr	r3, [r7, #4]
 8013c52:	629a      	str	r2, [r3, #40]	; 0x28
	/* Set the Repetition Counter value */
	TIMx->RCR = Config->RepetitionCounter;
 8013c54:	683b      	ldr	r3, [r7, #0]
 8013c56:	691a      	ldr	r2, [r3, #16]
 8013c58:	687b      	ldr	r3, [r7, #4]
 8013c5a:	631a      	str	r2, [r3, #48]	; 0x30

	TIMx->EGR = TIM_EGR_UG;
 8013c5c:	687b      	ldr	r3, [r7, #4]
 8013c5e:	2201      	movs	r2, #1
 8013c60:	615a      	str	r2, [r3, #20]
}
 8013c62:	bf00      	nop
 8013c64:	370c      	adds	r7, #12
 8013c66:	46bd      	mov	sp, r7
 8013c68:	bc80      	pop	{r7}
 8013c6a:	4770      	bx	lr

08013c6c <TIM_ConfigClockSource>:

void TIM_ConfigClockSource(TIM_TypeDef *TIMx,
		TIM_ClockConfigTypeDef *sClockSourceConfig) {
 8013c6c:	b480      	push	{r7}
 8013c6e:	b083      	sub	sp, #12
 8013c70:	af00      	add	r7, sp, #0
 8013c72:	6078      	str	r0, [r7, #4]
 8013c74:	6039      	str	r1, [r7, #0]
	TIMx->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 8013c76:	687b      	ldr	r3, [r7, #4]
 8013c78:	689b      	ldr	r3, [r3, #8]
 8013c7a:	f023 0277 	bic.w	r2, r3, #119	; 0x77
 8013c7e:	687b      	ldr	r3, [r7, #4]
 8013c80:	609a      	str	r2, [r3, #8]
	TIMx->SMCR &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8013c82:	687b      	ldr	r3, [r7, #4]
 8013c84:	689b      	ldr	r3, [r3, #8]
 8013c86:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8013c8a:	687b      	ldr	r3, [r7, #4]
 8013c8c:	609a      	str	r2, [r3, #8]

	switch (sClockSourceConfig->ClockSource) {
 8013c8e:	683b      	ldr	r3, [r7, #0]
 8013c90:	681b      	ldr	r3, [r3, #0]
 8013c92:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013c96:	d04f      	beq.n	8013d38 <TIM_ConfigClockSource+0xcc>
 8013c98:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8013c9c:	f200 8104 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013ca0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8013ca4:	f000 8102 	beq.w	8013eac <TIM_ConfigClockSource+0x240>
 8013ca8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8013cac:	f200 80fc 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013cb0:	2b70      	cmp	r3, #112	; 0x70
 8013cb2:	d026      	beq.n	8013d02 <TIM_ConfigClockSource+0x96>
 8013cb4:	2b70      	cmp	r3, #112	; 0x70
 8013cb6:	f200 80f7 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013cba:	2b60      	cmp	r3, #96	; 0x60
 8013cbc:	f000 8086 	beq.w	8013dcc <TIM_ConfigClockSource+0x160>
 8013cc0:	2b60      	cmp	r3, #96	; 0x60
 8013cc2:	f200 80f1 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013cc6:	2b50      	cmp	r3, #80	; 0x50
 8013cc8:	d051      	beq.n	8013d6e <TIM_ConfigClockSource+0x102>
 8013cca:	2b50      	cmp	r3, #80	; 0x50
 8013ccc:	f200 80ec 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013cd0:	2b40      	cmp	r3, #64	; 0x40
 8013cd2:	f000 80aa 	beq.w	8013e2a <TIM_ConfigClockSource+0x1be>
 8013cd6:	2b40      	cmp	r3, #64	; 0x40
 8013cd8:	f200 80e6 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013cdc:	2b30      	cmp	r3, #48	; 0x30
 8013cde:	f000 80d3 	beq.w	8013e88 <TIM_ConfigClockSource+0x21c>
 8013ce2:	2b30      	cmp	r3, #48	; 0x30
 8013ce4:	f200 80e0 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013ce8:	2b20      	cmp	r3, #32
 8013cea:	f000 80cd 	beq.w	8013e88 <TIM_ConfigClockSource+0x21c>
 8013cee:	2b20      	cmp	r3, #32
 8013cf0:	f200 80da 	bhi.w	8013ea8 <TIM_ConfigClockSource+0x23c>
 8013cf4:	2b00      	cmp	r3, #0
 8013cf6:	f000 80c7 	beq.w	8013e88 <TIM_ConfigClockSource+0x21c>
 8013cfa:	2b10      	cmp	r3, #16
 8013cfc:	f000 80c4 	beq.w	8013e88 <TIM_ConfigClockSource+0x21c>
		TIMx->SMCR |= (sClockSourceConfig->ClockSource | TIM_SLAVEMODE_EXTERNAL1);
		break;
	}

	default:
		break;
 8013d00:	e0d2      	b.n	8013ea8 <TIM_ConfigClockSource+0x23c>
		TIMx->SMCR &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE
 8013d02:	687b      	ldr	r3, [r7, #4]
 8013d04:	689b      	ldr	r3, [r3, #8]
 8013d06:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8013d0a:	687b      	ldr	r3, [r7, #4]
 8013d0c:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= (uint32_t) (sClockSourceConfig->ClockPrescaler
 8013d0e:	687b      	ldr	r3, [r7, #4]
 8013d10:	689a      	ldr	r2, [r3, #8]
 8013d12:	683b      	ldr	r3, [r7, #0]
 8013d14:	6899      	ldr	r1, [r3, #8]
				| (sClockSourceConfig->ClockPolarity
 8013d16:	683b      	ldr	r3, [r7, #0]
 8013d18:	6858      	ldr	r0, [r3, #4]
						| (sClockSourceConfig->ClockFilter << 8U)));
 8013d1a:	683b      	ldr	r3, [r7, #0]
 8013d1c:	68db      	ldr	r3, [r3, #12]
 8013d1e:	021b      	lsls	r3, r3, #8
 8013d20:	4303      	orrs	r3, r0
				| (sClockSourceConfig->ClockPolarity
 8013d22:	430b      	orrs	r3, r1
		TIMx->SMCR |= (uint32_t) (sClockSourceConfig->ClockPrescaler
 8013d24:	431a      	orrs	r2, r3
 8013d26:	687b      	ldr	r3, [r7, #4]
 8013d28:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8013d2a:	687b      	ldr	r3, [r7, #4]
 8013d2c:	689b      	ldr	r3, [r3, #8]
 8013d2e:	f043 0277 	orr.w	r2, r3, #119	; 0x77
 8013d32:	687b      	ldr	r3, [r7, #4]
 8013d34:	609a      	str	r2, [r3, #8]
		break;
 8013d36:	e0ba      	b.n	8013eae <TIM_ConfigClockSource+0x242>
		TIMx->SMCR &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE
 8013d38:	687b      	ldr	r3, [r7, #4]
 8013d3a:	689b      	ldr	r3, [r3, #8]
 8013d3c:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8013d40:	687b      	ldr	r3, [r7, #4]
 8013d42:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= (uint32_t) (sClockSourceConfig->ClockPrescaler
 8013d44:	687b      	ldr	r3, [r7, #4]
 8013d46:	689a      	ldr	r2, [r3, #8]
 8013d48:	683b      	ldr	r3, [r7, #0]
 8013d4a:	6899      	ldr	r1, [r3, #8]
				| (sClockSourceConfig->ClockPolarity
 8013d4c:	683b      	ldr	r3, [r7, #0]
 8013d4e:	6858      	ldr	r0, [r3, #4]
						| (sClockSourceConfig->ClockFilter << 8U)));
 8013d50:	683b      	ldr	r3, [r7, #0]
 8013d52:	68db      	ldr	r3, [r3, #12]
 8013d54:	021b      	lsls	r3, r3, #8
 8013d56:	4303      	orrs	r3, r0
				| (sClockSourceConfig->ClockPolarity
 8013d58:	430b      	orrs	r3, r1
		TIMx->SMCR |= (uint32_t) (sClockSourceConfig->ClockPrescaler
 8013d5a:	431a      	orrs	r2, r3
 8013d5c:	687b      	ldr	r3, [r7, #4]
 8013d5e:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= TIM_SMCR_ECE;
 8013d60:	687b      	ldr	r3, [r7, #4]
 8013d62:	689b      	ldr	r3, [r3, #8]
 8013d64:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 8013d68:	687b      	ldr	r3, [r7, #4]
 8013d6a:	609a      	str	r2, [r3, #8]
		break;
 8013d6c:	e09f      	b.n	8013eae <TIM_ConfigClockSource+0x242>
		TIMx->CCER &= ~TIM_CCER_CC2E;
 8013d6e:	687b      	ldr	r3, [r7, #4]
 8013d70:	6a1b      	ldr	r3, [r3, #32]
 8013d72:	f023 0210 	bic.w	r2, r3, #16
 8013d76:	687b      	ldr	r3, [r7, #4]
 8013d78:	621a      	str	r2, [r3, #32]
		TIMx->CCMR1 &= ~TIM_CCMR1_IC2F;
 8013d7a:	687b      	ldr	r3, [r7, #4]
 8013d7c:	699b      	ldr	r3, [r3, #24]
 8013d7e:	f423 4270 	bic.w	r2, r3, #61440	; 0xf000
 8013d82:	687b      	ldr	r3, [r7, #4]
 8013d84:	619a      	str	r2, [r3, #24]
		TIMx->CCMR1 |= (sClockSourceConfig->ClockFilter << 12U);
 8013d86:	687b      	ldr	r3, [r7, #4]
 8013d88:	699a      	ldr	r2, [r3, #24]
 8013d8a:	683b      	ldr	r3, [r7, #0]
 8013d8c:	68db      	ldr	r3, [r3, #12]
 8013d8e:	031b      	lsls	r3, r3, #12
 8013d90:	431a      	orrs	r2, r3
 8013d92:	687b      	ldr	r3, [r7, #4]
 8013d94:	619a      	str	r2, [r3, #24]
		TIMx->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8013d96:	687b      	ldr	r3, [r7, #4]
 8013d98:	6a1b      	ldr	r3, [r3, #32]
 8013d9a:	f023 02a0 	bic.w	r2, r3, #160	; 0xa0
 8013d9e:	687b      	ldr	r3, [r7, #4]
 8013da0:	621a      	str	r2, [r3, #32]
		TIMx->CCER |= (sClockSourceConfig->ClockPolarity << 4U);
 8013da2:	687b      	ldr	r3, [r7, #4]
 8013da4:	6a1a      	ldr	r2, [r3, #32]
 8013da6:	683b      	ldr	r3, [r7, #0]
 8013da8:	685b      	ldr	r3, [r3, #4]
 8013daa:	011b      	lsls	r3, r3, #4
 8013dac:	431a      	orrs	r2, r3
 8013dae:	687b      	ldr	r3, [r7, #4]
 8013db0:	621a      	str	r2, [r3, #32]
		TIMx->SMCR &= ~TIM_SMCR_TS;
 8013db2:	687b      	ldr	r3, [r7, #4]
 8013db4:	689b      	ldr	r3, [r3, #8]
 8013db6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8013dba:	687b      	ldr	r3, [r7, #4]
 8013dbc:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= (TIM_CLOCKSOURCE_TI1 | TIM_SLAVEMODE_EXTERNAL1);
 8013dbe:	687b      	ldr	r3, [r7, #4]
 8013dc0:	689b      	ldr	r3, [r3, #8]
 8013dc2:	f043 0257 	orr.w	r2, r3, #87	; 0x57
 8013dc6:	687b      	ldr	r3, [r7, #4]
 8013dc8:	609a      	str	r2, [r3, #8]
		break;
 8013dca:	e070      	b.n	8013eae <TIM_ConfigClockSource+0x242>
		TIMx->CCER &= ~TIM_CCER_CC2E;
 8013dcc:	687b      	ldr	r3, [r7, #4]
 8013dce:	6a1b      	ldr	r3, [r3, #32]
 8013dd0:	f023 0210 	bic.w	r2, r3, #16
 8013dd4:	687b      	ldr	r3, [r7, #4]
 8013dd6:	621a      	str	r2, [r3, #32]
		TIMx->CCMR1 &= ~TIM_CCMR1_IC2F;
 8013dd8:	687b      	ldr	r3, [r7, #4]
 8013dda:	699b      	ldr	r3, [r3, #24]
 8013ddc:	f423 4270 	bic.w	r2, r3, #61440	; 0xf000
 8013de0:	687b      	ldr	r3, [r7, #4]
 8013de2:	619a      	str	r2, [r3, #24]
		TIMx->CCMR1 |= (sClockSourceConfig->ClockFilter << 12U);
 8013de4:	687b      	ldr	r3, [r7, #4]
 8013de6:	699a      	ldr	r2, [r3, #24]
 8013de8:	683b      	ldr	r3, [r7, #0]
 8013dea:	68db      	ldr	r3, [r3, #12]
 8013dec:	031b      	lsls	r3, r3, #12
 8013dee:	431a      	orrs	r2, r3
 8013df0:	687b      	ldr	r3, [r7, #4]
 8013df2:	619a      	str	r2, [r3, #24]
		TIMx->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8013df4:	687b      	ldr	r3, [r7, #4]
 8013df6:	6a1b      	ldr	r3, [r3, #32]
 8013df8:	f023 02a0 	bic.w	r2, r3, #160	; 0xa0
 8013dfc:	687b      	ldr	r3, [r7, #4]
 8013dfe:	621a      	str	r2, [r3, #32]
		TIMx->CCER |= (sClockSourceConfig->ClockPolarity << 4U);
 8013e00:	687b      	ldr	r3, [r7, #4]
 8013e02:	6a1a      	ldr	r2, [r3, #32]
 8013e04:	683b      	ldr	r3, [r7, #0]
 8013e06:	685b      	ldr	r3, [r3, #4]
 8013e08:	011b      	lsls	r3, r3, #4
 8013e0a:	431a      	orrs	r2, r3
 8013e0c:	687b      	ldr	r3, [r7, #4]
 8013e0e:	621a      	str	r2, [r3, #32]
		TIMx->SMCR &= ~TIM_SMCR_TS;
 8013e10:	687b      	ldr	r3, [r7, #4]
 8013e12:	689b      	ldr	r3, [r3, #8]
 8013e14:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8013e18:	687b      	ldr	r3, [r7, #4]
 8013e1a:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= (TIM_CLOCKSOURCE_TI2 | TIM_SLAVEMODE_EXTERNAL1);
 8013e1c:	687b      	ldr	r3, [r7, #4]
 8013e1e:	689b      	ldr	r3, [r3, #8]
 8013e20:	f043 0267 	orr.w	r2, r3, #103	; 0x67
 8013e24:	687b      	ldr	r3, [r7, #4]
 8013e26:	609a      	str	r2, [r3, #8]
		break;
 8013e28:	e041      	b.n	8013eae <TIM_ConfigClockSource+0x242>
		TIMx->CCER &= ~TIM_CCER_CC2E;
 8013e2a:	687b      	ldr	r3, [r7, #4]
 8013e2c:	6a1b      	ldr	r3, [r3, #32]
 8013e2e:	f023 0210 	bic.w	r2, r3, #16
 8013e32:	687b      	ldr	r3, [r7, #4]
 8013e34:	621a      	str	r2, [r3, #32]
		TIMx->CCMR1 &= ~TIM_CCMR1_IC2F;
 8013e36:	687b      	ldr	r3, [r7, #4]
 8013e38:	699b      	ldr	r3, [r3, #24]
 8013e3a:	f423 4270 	bic.w	r2, r3, #61440	; 0xf000
 8013e3e:	687b      	ldr	r3, [r7, #4]
 8013e40:	619a      	str	r2, [r3, #24]
		TIMx->CCMR1 |= (sClockSourceConfig->ClockFilter << 12U);
 8013e42:	687b      	ldr	r3, [r7, #4]
 8013e44:	699a      	ldr	r2, [r3, #24]
 8013e46:	683b      	ldr	r3, [r7, #0]
 8013e48:	68db      	ldr	r3, [r3, #12]
 8013e4a:	031b      	lsls	r3, r3, #12
 8013e4c:	431a      	orrs	r2, r3
 8013e4e:	687b      	ldr	r3, [r7, #4]
 8013e50:	619a      	str	r2, [r3, #24]
		TIMx->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8013e52:	687b      	ldr	r3, [r7, #4]
 8013e54:	6a1b      	ldr	r3, [r3, #32]
 8013e56:	f023 02a0 	bic.w	r2, r3, #160	; 0xa0
 8013e5a:	687b      	ldr	r3, [r7, #4]
 8013e5c:	621a      	str	r2, [r3, #32]
		TIMx->CCER |= (sClockSourceConfig->ClockPolarity << 4U);
 8013e5e:	687b      	ldr	r3, [r7, #4]
 8013e60:	6a1a      	ldr	r2, [r3, #32]
 8013e62:	683b      	ldr	r3, [r7, #0]
 8013e64:	685b      	ldr	r3, [r3, #4]
 8013e66:	011b      	lsls	r3, r3, #4
 8013e68:	431a      	orrs	r2, r3
 8013e6a:	687b      	ldr	r3, [r7, #4]
 8013e6c:	621a      	str	r2, [r3, #32]
		TIMx->SMCR &= ~TIM_SMCR_TS;
 8013e6e:	687b      	ldr	r3, [r7, #4]
 8013e70:	689b      	ldr	r3, [r3, #8]
 8013e72:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8013e76:	687b      	ldr	r3, [r7, #4]
 8013e78:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= (TIM_CLOCKSOURCE_TI1 | TIM_SLAVEMODE_EXTERNAL1);
 8013e7a:	687b      	ldr	r3, [r7, #4]
 8013e7c:	689b      	ldr	r3, [r3, #8]
 8013e7e:	f043 0257 	orr.w	r2, r3, #87	; 0x57
 8013e82:	687b      	ldr	r3, [r7, #4]
 8013e84:	609a      	str	r2, [r3, #8]
		break;
 8013e86:	e012      	b.n	8013eae <TIM_ConfigClockSource+0x242>
		TIMx->SMCR &= ~TIM_SMCR_TS;
 8013e88:	687b      	ldr	r3, [r7, #4]
 8013e8a:	689b      	ldr	r3, [r3, #8]
 8013e8c:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8013e90:	687b      	ldr	r3, [r7, #4]
 8013e92:	609a      	str	r2, [r3, #8]
		TIMx->SMCR |= (sClockSourceConfig->ClockSource | TIM_SLAVEMODE_EXTERNAL1);
 8013e94:	687b      	ldr	r3, [r7, #4]
 8013e96:	689a      	ldr	r2, [r3, #8]
 8013e98:	683b      	ldr	r3, [r7, #0]
 8013e9a:	681b      	ldr	r3, [r3, #0]
 8013e9c:	4313      	orrs	r3, r2
 8013e9e:	f043 0207 	orr.w	r2, r3, #7
 8013ea2:	687b      	ldr	r3, [r7, #4]
 8013ea4:	609a      	str	r2, [r3, #8]
		break;
 8013ea6:	e002      	b.n	8013eae <TIM_ConfigClockSource+0x242>
		break;
 8013ea8:	bf00      	nop
 8013eaa:	e000      	b.n	8013eae <TIM_ConfigClockSource+0x242>
		break;
 8013eac:	bf00      	nop
	}
}
 8013eae:	bf00      	nop
 8013eb0:	370c      	adds	r7, #12
 8013eb2:	46bd      	mov	sp, r7
 8013eb4:	bc80      	pop	{r7}
 8013eb6:	4770      	bx	lr

08013eb8 <TIM_MasterConfigSynchronization>:

void TIM_MasterConfigSynchronization(TIM_TypeDef *TIMx, uint32_t masterOutputTrigger, uint32_t masterSlaveMode){
 8013eb8:	b480      	push	{r7}
 8013eba:	b085      	sub	sp, #20
 8013ebc:	af00      	add	r7, sp, #0
 8013ebe:	60f8      	str	r0, [r7, #12]
 8013ec0:	60b9      	str	r1, [r7, #8]
 8013ec2:	607a      	str	r2, [r7, #4]
	TIMx->CR2 &= ~TIM_CR2_MMS;
 8013ec4:	68fb      	ldr	r3, [r7, #12]
 8013ec6:	685b      	ldr	r3, [r3, #4]
 8013ec8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8013ecc:	68fb      	ldr	r3, [r7, #12]
 8013ece:	605a      	str	r2, [r3, #4]
	TIMx->CR2 |= masterOutputTrigger;
 8013ed0:	68fb      	ldr	r3, [r7, #12]
 8013ed2:	685a      	ldr	r2, [r3, #4]
 8013ed4:	68bb      	ldr	r3, [r7, #8]
 8013ed6:	431a      	orrs	r2, r3
 8013ed8:	68fb      	ldr	r3, [r7, #12]
 8013eda:	605a      	str	r2, [r3, #4]
	TIMx->SMCR &= ~TIM_SMCR_MSM;
 8013edc:	68fb      	ldr	r3, [r7, #12]
 8013ede:	689b      	ldr	r3, [r3, #8]
 8013ee0:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8013ee4:	68fb      	ldr	r3, [r7, #12]
 8013ee6:	609a      	str	r2, [r3, #8]
	TIMx->SMCR |= masterSlaveMode;
 8013ee8:	68fb      	ldr	r3, [r7, #12]
 8013eea:	689a      	ldr	r2, [r3, #8]
 8013eec:	687b      	ldr	r3, [r7, #4]
 8013eee:	431a      	orrs	r2, r3
 8013ef0:	68fb      	ldr	r3, [r7, #12]
 8013ef2:	609a      	str	r2, [r3, #8]

}
 8013ef4:	bf00      	nop
 8013ef6:	3714      	adds	r7, #20
 8013ef8:	46bd      	mov	sp, r7
 8013efa:	bc80      	pop	{r7}
 8013efc:	4770      	bx	lr

08013efe <TIM_Base_Start>:

void TIM_Base_Start(TIM_TypeDef *TIMx){
 8013efe:	b480      	push	{r7}
 8013f00:	b083      	sub	sp, #12
 8013f02:	af00      	add	r7, sp, #0
 8013f04:	6078      	str	r0, [r7, #4]
	TIMx->CR1|=(TIM_CR1_CEN);
 8013f06:	687b      	ldr	r3, [r7, #4]
 8013f08:	681b      	ldr	r3, [r3, #0]
 8013f0a:	f043 0201 	orr.w	r2, r3, #1
 8013f0e:	687b      	ldr	r3, [r7, #4]
 8013f10:	601a      	str	r2, [r3, #0]

}
 8013f12:	bf00      	nop
 8013f14:	370c      	adds	r7, #12
 8013f16:	46bd      	mov	sp, r7
 8013f18:	bc80      	pop	{r7}
 8013f1a:	4770      	bx	lr

08013f1c <TIM_GetCounter>:

uint32_t TIM_GetCounter(TIM_TypeDef *TIMx){
 8013f1c:	b480      	push	{r7}
 8013f1e:	b083      	sub	sp, #12
 8013f20:	af00      	add	r7, sp, #0
 8013f22:	6078      	str	r0, [r7, #4]
	return (TIMx->CNT);
 8013f24:	687b      	ldr	r3, [r7, #4]
 8013f26:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8013f28:	4618      	mov	r0, r3
 8013f2a:	370c      	adds	r7, #12
 8013f2c:	46bd      	mov	sp, r7
 8013f2e:	bc80      	pop	{r7}
 8013f30:	4770      	bx	lr

08013f32 <TIM_SetCounter>:
void TIM_SetCounter(TIM_TypeDef *TIMx, uint32_t value){
 8013f32:	b480      	push	{r7}
 8013f34:	b083      	sub	sp, #12
 8013f36:	af00      	add	r7, sp, #0
 8013f38:	6078      	str	r0, [r7, #4]
 8013f3a:	6039      	str	r1, [r7, #0]
	TIMx->CNT = value;
 8013f3c:	687b      	ldr	r3, [r7, #4]
 8013f3e:	683a      	ldr	r2, [r7, #0]
 8013f40:	625a      	str	r2, [r3, #36]	; 0x24
}
 8013f42:	bf00      	nop
 8013f44:	370c      	adds	r7, #12
 8013f46:	46bd      	mov	sp, r7
 8013f48:	bc80      	pop	{r7}
 8013f4a:	4770      	bx	lr
 8013f4c:	0000      	movs	r0, r0
	...

08013f50 <ULTRASONIC_GetDistance>:

void jumpToBoot(void);
uint16_t ULTRASONIC_GetDistance(void);
void CAN_SendData(uint8_t* buffer, uint16_t length, uint32_t CAN_id);

uint16_t ULTRASONIC_GetDistance(void){
 8013f50:	b590      	push	{r4, r7, lr}
 8013f52:	b085      	sub	sp, #20
 8013f54:	af00      	add	r7, sp, #0
	uint32_t Value1 = 0;
 8013f56:	2300      	movs	r3, #0
 8013f58:	60fb      	str	r3, [r7, #12]
	uint32_t Value2 = 0;
 8013f5a:	2300      	movs	r3, #0
 8013f5c:	60bb      	str	r3, [r7, #8]
	uint32_t SysTicks = 0;
 8013f5e:	2300      	movs	r3, #0
 8013f60:	607b      	str	r3, [r7, #4]
	GPIO_Write_Pin(GPIOA, GPIO_PIN_9, HIGH);
 8013f62:	2201      	movs	r2, #1
 8013f64:	2109      	movs	r1, #9
 8013f66:	4834      	ldr	r0, [pc, #208]	; (8014038 <ULTRASONIC_GetDistance+0xe8>)
 8013f68:	f7ff fc85 	bl	8013876 <GPIO_Write_Pin>
	TIM_SetCounter(TIM1, 0);
 8013f6c:	2100      	movs	r1, #0
 8013f6e:	4833      	ldr	r0, [pc, #204]	; (801403c <ULTRASONIC_GetDistance+0xec>)
 8013f70:	f7ff ffdf 	bl	8013f32 <TIM_SetCounter>
	while (TIM_GetCounter(TIM1) < 10);
 8013f74:	bf00      	nop
 8013f76:	4831      	ldr	r0, [pc, #196]	; (801403c <ULTRASONIC_GetDistance+0xec>)
 8013f78:	f7ff ffd0 	bl	8013f1c <TIM_GetCounter>
 8013f7c:	4603      	mov	r3, r0
 8013f7e:	2b09      	cmp	r3, #9
 8013f80:	d9f9      	bls.n	8013f76 <ULTRASONIC_GetDistance+0x26>
	GPIO_Write_Pin(GPIOA, GPIO_PIN_9, LOW);
 8013f82:	2200      	movs	r2, #0
 8013f84:	2109      	movs	r1, #9
 8013f86:	482c      	ldr	r0, [pc, #176]	; (8014038 <ULTRASONIC_GetDistance+0xe8>)
 8013f88:	f7ff fc75 	bl	8013876 <GPIO_Write_Pin>
	SysTicks = SysTick_GetTicks();
 8013f8c:	f7ff fe24 	bl	8013bd8 <SysTick_GetTicks>
 8013f90:	6078      	str	r0, [r7, #4]

	while(!(GPIO_Read_Pin(GPIOA, GPIO_PIN_8)) && (SysTicks + 10 >  SysTick_GetTicks()));
 8013f92:	bf00      	nop
 8013f94:	2108      	movs	r1, #8
 8013f96:	4828      	ldr	r0, [pc, #160]	; (8014038 <ULTRASONIC_GetDistance+0xe8>)
 8013f98:	f7ff fc59 	bl	801384e <GPIO_Read_Pin>
 8013f9c:	4603      	mov	r3, r0
 8013f9e:	2b00      	cmp	r3, #0
 8013fa0:	d107      	bne.n	8013fb2 <ULTRASONIC_GetDistance+0x62>
 8013fa2:	687b      	ldr	r3, [r7, #4]
 8013fa4:	f103 040a 	add.w	r4, r3, #10
 8013fa8:	f7ff fe16 	bl	8013bd8 <SysTick_GetTicks>
 8013fac:	4603      	mov	r3, r0
 8013fae:	429c      	cmp	r4, r3
 8013fb0:	d8f0      	bhi.n	8013f94 <ULTRASONIC_GetDistance+0x44>
	Value1 = TIM_GetCounter(TIM1);
 8013fb2:	4822      	ldr	r0, [pc, #136]	; (801403c <ULTRASONIC_GetDistance+0xec>)
 8013fb4:	f7ff ffb2 	bl	8013f1c <TIM_GetCounter>
 8013fb8:	60f8      	str	r0, [r7, #12]

	SysTicks = SysTick_GetTicks();
 8013fba:	f7ff fe0d 	bl	8013bd8 <SysTick_GetTicks>
 8013fbe:	6078      	str	r0, [r7, #4]
	while(GPIO_Read_Pin(GPIOA, GPIO_PIN_8) && (SysTicks + 50 > SysTick_GetTicks()));
 8013fc0:	bf00      	nop
 8013fc2:	2108      	movs	r1, #8
 8013fc4:	481c      	ldr	r0, [pc, #112]	; (8014038 <ULTRASONIC_GetDistance+0xe8>)
 8013fc6:	f7ff fc42 	bl	801384e <GPIO_Read_Pin>
 8013fca:	4603      	mov	r3, r0
 8013fcc:	2b00      	cmp	r3, #0
 8013fce:	d007      	beq.n	8013fe0 <ULTRASONIC_GetDistance+0x90>
 8013fd0:	687b      	ldr	r3, [r7, #4]
 8013fd2:	f103 0432 	add.w	r4, r3, #50	; 0x32
 8013fd6:	f7ff fdff 	bl	8013bd8 <SysTick_GetTicks>
 8013fda:	4603      	mov	r3, r0
 8013fdc:	429c      	cmp	r4, r3
 8013fde:	d8f0      	bhi.n	8013fc2 <ULTRASONIC_GetDistance+0x72>
	Value2 = TIM_GetCounter(TIM1);
 8013fe0:	4816      	ldr	r0, [pc, #88]	; (801403c <ULTRASONIC_GetDistance+0xec>)
 8013fe2:	f7ff ff9b 	bl	8013f1c <TIM_GetCounter>
 8013fe6:	60b8      	str	r0, [r7, #8]

	return((Value2-Value1)* 0.03448/2);
 8013fe8:	68ba      	ldr	r2, [r7, #8]
 8013fea:	68fb      	ldr	r3, [r7, #12]
 8013fec:	1ad3      	subs	r3, r2, r3
 8013fee:	4618      	mov	r0, r3
 8013ff0:	f7fe fdf0 	bl	8012bd4 <__aeabi_ui2d>
 8013ff4:	a30e      	add	r3, pc, #56	; (adr r3, 8014030 <ULTRASONIC_GetDistance+0xe0>)
 8013ff6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013ffa:	f7fe fe65 	bl	8012cc8 <__aeabi_dmul>
 8013ffe:	4602      	mov	r2, r0
 8014000:	460b      	mov	r3, r1
 8014002:	4610      	mov	r0, r2
 8014004:	4619      	mov	r1, r3
 8014006:	f04f 0200 	mov.w	r2, #0
 801400a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 801400e:	f7fe ff85 	bl	8012f1c <__aeabi_ddiv>
 8014012:	4602      	mov	r2, r0
 8014014:	460b      	mov	r3, r1
 8014016:	4610      	mov	r0, r2
 8014018:	4619      	mov	r1, r3
 801401a:	f7ff f867 	bl	80130ec <__aeabi_d2uiz>
 801401e:	4603      	mov	r3, r0
 8014020:	b29b      	uxth	r3, r3
}
 8014022:	4618      	mov	r0, r3
 8014024:	3714      	adds	r7, #20
 8014026:	46bd      	mov	sp, r7
 8014028:	bd90      	pop	{r4, r7, pc}
 801402a:	bf00      	nop
 801402c:	f3af 8000 	nop.w
 8014030:	d0bb6ed6 	.word	0xd0bb6ed6
 8014034:	3fa1a75c 	.word	0x3fa1a75c
 8014038:	40010800 	.word	0x40010800
 801403c:	40012c00 	.word	0x40012c00

08014040 <main>:

uint8_t isdiagRequest = 0;
uint8_t isBootloaderRQ = 0;
const uint8_t currentVersion[] = "2.0.0";
const uint8_t ecu_id = 1;
int main(void) {
 8014040:	b580      	push	{r7, lr}
 8014042:	b096      	sub	sp, #88	; 0x58
 8014044:	af00      	add	r7, sp, #0
	FLASH_Unlock();
 8014046:	f7ff fb31 	bl	80136ac <FLASH_Unlock>
	FLASH_Program(FLASH_TYPEPROGRAM_WORD, BOOTLOADER_CURRENTBANK_ADDRESS, APP2_START_ADDRESS);
 801404a:	4a98      	ldr	r2, [pc, #608]	; (80142ac <main+0x26c>)
 801404c:	f04f 0300 	mov.w	r3, #0
 8014050:	4997      	ldr	r1, [pc, #604]	; (80142b0 <main+0x270>)
 8014052:	2002      	movs	r0, #2
 8014054:	f7ff fb4a 	bl	80136ec <FLASH_Program>
	FLASH_Lock();
 8014058:	f7ff fb3a 	bl	80136d0 <FLASH_Lock>
	RCC_Config();
 801405c:	f7ff fc74 	bl	8013948 <RCC_Config>
	SCB->VTOR = 0x08005000 - 0x08000000;
 8014060:	4b94      	ldr	r3, [pc, #592]	; (80142b4 <main+0x274>)
 8014062:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
 8014066:	609a      	str	r2, [r3, #8]
	Enable_irq();
 8014068:	f7ff fc2c 	bl	80138c4 <Enable_irq>
	NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 801406c:	2014      	movs	r0, #20
 801406e:	f7ff fc37 	bl	80138e0 <NVIC_EnableIRQ>
	SysTick_INIT();
 8014072:	f7ff fd7f 	bl	8013b74 <SysTick_INIT>

	RCC_EnablePeripheral(RCC_AFIOCLK);
 8014076:	2000      	movs	r0, #0
 8014078:	f7ff fcde 	bl	8013a38 <RCC_EnablePeripheral>
	RCC_EnablePeripheral(RCC_GPIOACLK);
 801407c:	2002      	movs	r0, #2
 801407e:	f7ff fcdb 	bl	8013a38 <RCC_EnablePeripheral>
	RCC_EnablePeripheral(RCC_GPIOCCLK);
 8014082:	2004      	movs	r0, #4
 8014084:	f7ff fcd8 	bl	8013a38 <RCC_EnablePeripheral>
	RCC_EnablePeripheral(RCC_CANCLK);
 8014088:	2039      	movs	r0, #57	; 0x39
 801408a:	f7ff fcd5 	bl	8013a38 <RCC_EnablePeripheral>
	//for ultrasonic
	RCC_EnablePeripheral(RCC_TIM1CLK);
 801408e:	200b      	movs	r0, #11
 8014090:	f7ff fcd2 	bl	8013a38 <RCC_EnablePeripheral>

	AFIO_INIT();
 8014094:	f7ff f84a 	bl	801312c <AFIO_INIT>
	GPIO_Config_Pin(GPIOC, GPIO_PIN_13, GPIO_PINMODE_OUTPUT50MHZ);
 8014098:	2203      	movs	r2, #3
 801409a:	210d      	movs	r1, #13
 801409c:	4886      	ldr	r0, [pc, #536]	; (80142b8 <main+0x278>)
 801409e:	f7ff fb95 	bl	80137cc <GPIO_Config_Pin>
	GPIO_Config_Pin(GPIOA, GPIO_PIN_11, GPIO_PINMODE_INPUT); //rx
 80140a2:	2208      	movs	r2, #8
 80140a4:	210b      	movs	r1, #11
 80140a6:	4885      	ldr	r0, [pc, #532]	; (80142bc <main+0x27c>)
 80140a8:	f7ff fb90 	bl	80137cc <GPIO_Config_Pin>
	GPIO_Config_Pin(GPIOA, GPIO_PIN_12, GPIO_PINMODE_AFIO); //tx
 80140ac:	220b      	movs	r2, #11
 80140ae:	210c      	movs	r1, #12
 80140b0:	4882      	ldr	r0, [pc, #520]	; (80142bc <main+0x27c>)
 80140b2:	f7ff fb8b 	bl	80137cc <GPIO_Config_Pin>

	GPIO_Config_Pin(GPIOA, GPIO_PIN_9, GPIO_PINMODE_OUTPUT50MHZ);//trigger
 80140b6:	2203      	movs	r2, #3
 80140b8:	2109      	movs	r1, #9
 80140ba:	4880      	ldr	r0, [pc, #512]	; (80142bc <main+0x27c>)
 80140bc:	f7ff fb86 	bl	80137cc <GPIO_Config_Pin>
	GPIO_Config_Pin(GPIOA, GPIO_PIN_8, GPIO_PINMODE_INPUT);//echo
 80140c0:	2208      	movs	r2, #8
 80140c2:	2108      	movs	r1, #8
 80140c4:	487d      	ldr	r0, [pc, #500]	; (80142bc <main+0x27c>)
 80140c6:	f7ff fb81 	bl	80137cc <GPIO_Config_Pin>
	GPIO_Config_Pin(GPIOA, GPIO_PIN_10, GPIO_PINMODE_OUTPUT50MHZ);//Buzzer
 80140ca:	2203      	movs	r2, #3
 80140cc:	210a      	movs	r1, #10
 80140ce:	487b      	ldr	r0, [pc, #492]	; (80142bc <main+0x27c>)
 80140d0:	f7ff fb7c 	bl	80137cc <GPIO_Config_Pin>

	CAN_setupTypeDef CANsetupStruct = { DISABLE, DISABLE, DISABLE, DISABLE,
 80140d4:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80140d8:	2200      	movs	r2, #0
 80140da:	601a      	str	r2, [r3, #0]
 80140dc:	809a      	strh	r2, [r3, #4]
			DISABLE, DISABLE, };
	CAN_Setup(CAN, &CANsetupStruct);
 80140de:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80140e2:	4619      	mov	r1, r3
 80140e4:	4876      	ldr	r0, [pc, #472]	; (80142c0 <main+0x280>)
 80140e6:	f7ff f835 	bl	8013154 <CAN_Setup>
	CAN_Normal(CAN);
 80140ea:	4875      	ldr	r0, [pc, #468]	; (80142c0 <main+0x280>)
 80140ec:	f7ff f8ba 	bl	8013264 <CAN_Normal>
	CAN_FilterTypeDef filterConfig;
	filterConfig.FilterActivation = CAN_FILTER_ENABLE;
 80140f0:	2300      	movs	r3, #0
 80140f2:	64fb      	str	r3, [r7, #76]	; 0x4c
	filterConfig.FilterBank = 1;
 80140f4:	2301      	movs	r3, #1
 80140f6:	647b      	str	r3, [r7, #68]	; 0x44
	filterConfig.FilterFIFOAssignment = CAN_FIFO0;
 80140f8:	2300      	movs	r3, #0
 80140fa:	643b      	str	r3, [r7, #64]	; 0x40
	filterConfig.FilterId = CAN_CURRENTVERSION_ID;
 80140fc:	2307      	movs	r3, #7
 80140fe:	63bb      	str	r3, [r7, #56]	; 0x38
	filterConfig.FilterMaskId = CAN_CURRENTVERSION_ID;
 8014100:	2307      	movs	r3, #7
 8014102:	63fb      	str	r3, [r7, #60]	; 0x3c
	filterConfig.FilterMode = CAN_FILTERMODE_LIST;
 8014104:	2301      	movs	r3, #1
 8014106:	64bb      	str	r3, [r7, #72]	; 0x48
	CAN_ConfigFilter(CAN, &filterConfig);
 8014108:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801410c:	4619      	mov	r1, r3
 801410e:	486c      	ldr	r0, [pc, #432]	; (80142c0 <main+0x280>)
 8014110:	f7ff fa4e 	bl	80135b0 <CAN_ConfigFilter>
	filterConfig.FilterActivation = CAN_FILTER_ENABLE;
 8014114:	2300      	movs	r3, #0
 8014116:	64fb      	str	r3, [r7, #76]	; 0x4c
	filterConfig.FilterBank = 2;
 8014118:	2302      	movs	r3, #2
 801411a:	647b      	str	r3, [r7, #68]	; 0x44
	filterConfig.FilterFIFOAssignment = CAN_FIFO0;
 801411c:	2300      	movs	r3, #0
 801411e:	643b      	str	r3, [r7, #64]	; 0x40
	filterConfig.FilterId = CAN_BOOTLOADER_RQ_ID;
 8014120:	f240 1323 	movw	r3, #291	; 0x123
 8014124:	63bb      	str	r3, [r7, #56]	; 0x38
	filterConfig.FilterMaskId = CAN_BOOTLOADER_RQ_ID;
 8014126:	f240 1323 	movw	r3, #291	; 0x123
 801412a:	63fb      	str	r3, [r7, #60]	; 0x3c
	filterConfig.FilterMode = CAN_FILTERMODE_LIST;
 801412c:	2301      	movs	r3, #1
 801412e:	64bb      	str	r3, [r7, #72]	; 0x48
	CAN_ConfigFilter(CAN, &filterConfig);
 8014130:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8014134:	4619      	mov	r1, r3
 8014136:	4862      	ldr	r0, [pc, #392]	; (80142c0 <main+0x280>)
 8014138:	f7ff fa3a 	bl	80135b0 <CAN_ConfigFilter>
	CAN_Interrupt_Enable(CAN, CAN_IER_FMPIE0, ENABLE);
 801413c:	2201      	movs	r2, #1
 801413e:	2102      	movs	r1, #2
 8014140:	485f      	ldr	r0, [pc, #380]	; (80142c0 <main+0x280>)
 8014142:	f7ff fa15 	bl	8013570 <CAN_Interrupt_Enable>
	filterConfig.FilterActivation = CAN_FILTER_ENABLE;
 8014146:	2300      	movs	r3, #0
 8014148:	64fb      	str	r3, [r7, #76]	; 0x4c
	filterConfig.FilterBank = 3;
 801414a:	2303      	movs	r3, #3
 801414c:	647b      	str	r3, [r7, #68]	; 0x44
	filterConfig.FilterFIFOAssignment = CAN_FIFO0;
 801414e:	2300      	movs	r3, #0
 8014150:	643b      	str	r3, [r7, #64]	; 0x40
	filterConfig.FilterId = ECU_DIAGNOSTIC_LOG_ID;
 8014152:	2316      	movs	r3, #22
 8014154:	63bb      	str	r3, [r7, #56]	; 0x38
	filterConfig.FilterMaskId = ECU_DIAGNOSTIC_LOG_ID;
 8014156:	2316      	movs	r3, #22
 8014158:	63fb      	str	r3, [r7, #60]	; 0x3c
	filterConfig.FilterMode = CAN_FILTERMODE_LIST;
 801415a:	2301      	movs	r3, #1
 801415c:	64bb      	str	r3, [r7, #72]	; 0x48
	CAN_ConfigFilter(CAN, &filterConfig);
 801415e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8014162:	4619      	mov	r1, r3
 8014164:	4856      	ldr	r0, [pc, #344]	; (80142c0 <main+0x280>)
 8014166:	f7ff fa23 	bl	80135b0 <CAN_ConfigFilter>
	CAN_Interrupt_Enable(CAN, CAN_IER_FMPIE0, ENABLE);
 801416a:	2201      	movs	r2, #1
 801416c:	2102      	movs	r1, #2
 801416e:	4854      	ldr	r0, [pc, #336]	; (80142c0 <main+0x280>)
 8014170:	f7ff f9fe 	bl	8013570 <CAN_Interrupt_Enable>

	//Timer Configuration
	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8014174:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8014178:	2200      	movs	r2, #0
 801417a:	601a      	str	r2, [r3, #0]
 801417c:	605a      	str	r2, [r3, #4]
 801417e:	609a      	str	r2, [r3, #8]
 8014180:	60da      	str	r2, [r3, #12]
	TIM_Base_InitTypeDef Config ={0};
 8014182:	f107 0310 	add.w	r3, r7, #16
 8014186:	2200      	movs	r2, #0
 8014188:	601a      	str	r2, [r3, #0]
 801418a:	605a      	str	r2, [r3, #4]
 801418c:	609a      	str	r2, [r3, #8]
 801418e:	60da      	str	r2, [r3, #12]
 8014190:	611a      	str	r2, [r3, #16]
 8014192:	615a      	str	r2, [r3, #20]
	Config.Prescaler = 72 - 1;
 8014194:	2347      	movs	r3, #71	; 0x47
 8014196:	613b      	str	r3, [r7, #16]
	Config.CounterMode = TIM_COUNTERMODE_UP;
 8014198:	2300      	movs	r3, #0
 801419a:	617b      	str	r3, [r7, #20]
	Config.Period = 0xffff;
 801419c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80141a0:	61bb      	str	r3, [r7, #24]
	Config.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80141a2:	2300      	movs	r3, #0
 80141a4:	61fb      	str	r3, [r7, #28]
	Config.RepetitionCounter = 0;
 80141a6:	2300      	movs	r3, #0
 80141a8:	623b      	str	r3, [r7, #32]
	Config.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80141aa:	2300      	movs	r3, #0
 80141ac:	627b      	str	r3, [r7, #36]	; 0x24
	TIM_Base_SetConfig(TIM1, &Config);
 80141ae:	f107 0310 	add.w	r3, r7, #16
 80141b2:	4619      	mov	r1, r3
 80141b4:	4843      	ldr	r0, [pc, #268]	; (80142c4 <main+0x284>)
 80141b6:	f7ff fd19 	bl	8013bec <TIM_Base_SetConfig>

	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80141ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80141be:	62bb      	str	r3, [r7, #40]	; 0x28
	TIM_ConfigClockSource(TIM1, &sClockSourceConfig);
 80141c0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80141c4:	4619      	mov	r1, r3
 80141c6:	483f      	ldr	r0, [pc, #252]	; (80142c4 <main+0x284>)
 80141c8:	f7ff fd50 	bl	8013c6c <TIM_ConfigClockSource>
	TIM_MasterConfigSynchronization(TIM1, TIM_TRGO_RESET, TIM_MASTERSLAVEMODE_DISABLE);
 80141cc:	2200      	movs	r2, #0
 80141ce:	2100      	movs	r1, #0
 80141d0:	483c      	ldr	r0, [pc, #240]	; (80142c4 <main+0x284>)
 80141d2:	f7ff fe71 	bl	8013eb8 <TIM_MasterConfigSynchronization>

	TIM_Base_Start(TIM1);
 80141d6:	483b      	ldr	r0, [pc, #236]	; (80142c4 <main+0x284>)
 80141d8:	f7ff fe91 	bl	8013efe <TIM_Base_Start>
	GPIO_Write_Pin(GPIOA, GPIO_PIN_9, LOW);
 80141dc:	2200      	movs	r2, #0
 80141de:	2109      	movs	r1, #9
 80141e0:	4836      	ldr	r0, [pc, #216]	; (80142bc <main+0x27c>)
 80141e2:	f7ff fb48 	bl	8013876 <GPIO_Write_Pin>


	while(1){
		Distance = ULTRASONIC_GetDistance();
 80141e6:	f7ff feb3 	bl	8013f50 <ULTRASONIC_GetDistance>
 80141ea:	4603      	mov	r3, r0
 80141ec:	461a      	mov	r2, r3
 80141ee:	4b36      	ldr	r3, [pc, #216]	; (80142c8 <main+0x288>)
 80141f0:	801a      	strh	r2, [r3, #0]
			GPIO_Write_Pin(GPIOA, GPIO_PIN_10, LOW);
			SysTick_Delay(500);
	        }
		*/
		//APP2
		if((Distance < 40) & (Distance > 2)){
 80141f2:	4b35      	ldr	r3, [pc, #212]	; (80142c8 <main+0x288>)
 80141f4:	881b      	ldrh	r3, [r3, #0]
 80141f6:	2b27      	cmp	r3, #39	; 0x27
 80141f8:	bf94      	ite	ls
 80141fa:	2301      	movls	r3, #1
 80141fc:	2300      	movhi	r3, #0
 80141fe:	b2da      	uxtb	r2, r3
 8014200:	4b31      	ldr	r3, [pc, #196]	; (80142c8 <main+0x288>)
 8014202:	881b      	ldrh	r3, [r3, #0]
 8014204:	2b02      	cmp	r3, #2
 8014206:	bf8c      	ite	hi
 8014208:	2301      	movhi	r3, #1
 801420a:	2300      	movls	r3, #0
 801420c:	b2db      	uxtb	r3, r3
 801420e:	4013      	ands	r3, r2
 8014210:	b2db      	uxtb	r3, r3
 8014212:	2b00      	cmp	r3, #0
 8014214:	d01d      	beq.n	8014252 <main+0x212>
			GPIO_Write_Pin(GPIOA, GPIO_PIN_10, HIGH);
 8014216:	2201      	movs	r2, #1
 8014218:	210a      	movs	r1, #10
 801421a:	4828      	ldr	r0, [pc, #160]	; (80142bc <main+0x27c>)
 801421c:	f7ff fb2b 	bl	8013876 <GPIO_Write_Pin>
			SysTick_Delay(Distance * 10);
 8014220:	4b29      	ldr	r3, [pc, #164]	; (80142c8 <main+0x288>)
 8014222:	881b      	ldrh	r3, [r3, #0]
 8014224:	461a      	mov	r2, r3
 8014226:	4613      	mov	r3, r2
 8014228:	009b      	lsls	r3, r3, #2
 801422a:	4413      	add	r3, r2
 801422c:	005b      	lsls	r3, r3, #1
 801422e:	4618      	mov	r0, r3
 8014230:	f7ff fcb6 	bl	8013ba0 <SysTick_Delay>
			GPIO_Write_Pin(GPIOA, GPIO_PIN_10, LOW);
 8014234:	2200      	movs	r2, #0
 8014236:	210a      	movs	r1, #10
 8014238:	4820      	ldr	r0, [pc, #128]	; (80142bc <main+0x27c>)
 801423a:	f7ff fb1c 	bl	8013876 <GPIO_Write_Pin>
			SysTick_Delay(Distance * 10);
 801423e:	4b22      	ldr	r3, [pc, #136]	; (80142c8 <main+0x288>)
 8014240:	881b      	ldrh	r3, [r3, #0]
 8014242:	461a      	mov	r2, r3
 8014244:	4613      	mov	r3, r2
 8014246:	009b      	lsls	r3, r3, #2
 8014248:	4413      	add	r3, r2
 801424a:	005b      	lsls	r3, r3, #1
 801424c:	4618      	mov	r0, r3
 801424e:	f7ff fca7 	bl	8013ba0 <SysTick_Delay>
		}

		if(isdiagRequest == 1){
 8014252:	4b1e      	ldr	r3, [pc, #120]	; (80142cc <main+0x28c>)
 8014254:	781b      	ldrb	r3, [r3, #0]
 8014256:	2b01      	cmp	r3, #1
 8014258:	d11e      	bne.n	8014298 <main+0x258>
			isdiagRequest = 0;
 801425a:	4b1c      	ldr	r3, [pc, #112]	; (80142cc <main+0x28c>)
 801425c:	2200      	movs	r2, #0
 801425e:	701a      	strb	r2, [r3, #0]
			CAN_msg msg = {0};
 8014260:	463b      	mov	r3, r7
 8014262:	2200      	movs	r2, #0
 8014264:	601a      	str	r2, [r3, #0]
 8014266:	605a      	str	r2, [r3, #4]
 8014268:	609a      	str	r2, [r3, #8]
 801426a:	60da      	str	r2, [r3, #12]
			msg.id = CAN_DATA_ID;
 801426c:	2306      	movs	r3, #6
 801426e:	603b      	str	r3, [r7, #0]
			msg.format = STANDARD_FORMAT;
 8014270:	2300      	movs	r3, #0
 8014272:	737b      	strb	r3, [r7, #13]
			msg.type = DATA_FRAME;
 8014274:	2300      	movs	r3, #0
 8014276:	73bb      	strb	r3, [r7, #14]
			msg.length = 2;
 8014278:	2302      	movs	r3, #2
 801427a:	733b      	strb	r3, [r7, #12]
			msg.data[0] = (uint8_t)(0xFF & sizeof(diagFile));
 801427c:	23ce      	movs	r3, #206	; 0xce
 801427e:	713b      	strb	r3, [r7, #4]
			msg.data[1] = (uint8_t)(0xFF & (sizeof(diagFile) >> 8));
 8014280:	2300      	movs	r3, #0
 8014282:	717b      	strb	r3, [r7, #5]
			CAN_Transmit(CAN, &msg);
 8014284:	463b      	mov	r3, r7
 8014286:	4619      	mov	r1, r3
 8014288:	480d      	ldr	r0, [pc, #52]	; (80142c0 <main+0x280>)
 801428a:	f7ff f802 	bl	8013292 <CAN_Transmit>
			CAN_SendData(diagFile, sizeof(diagFile), CAN_DATA_ID);
 801428e:	2206      	movs	r2, #6
 8014290:	21ce      	movs	r1, #206	; 0xce
 8014292:	480f      	ldr	r0, [pc, #60]	; (80142d0 <main+0x290>)
 8014294:	f000 f820 	bl	80142d8 <CAN_SendData>

		}
		if(isBootloaderRQ){
 8014298:	4b0e      	ldr	r3, [pc, #56]	; (80142d4 <main+0x294>)
 801429a:	781b      	ldrb	r3, [r3, #0]
 801429c:	2b00      	cmp	r3, #0
 801429e:	d0a2      	beq.n	80141e6 <main+0x1a6>
			isBootloaderRQ = 0;
 80142a0:	4b0c      	ldr	r3, [pc, #48]	; (80142d4 <main+0x294>)
 80142a2:	2200      	movs	r2, #0
 80142a4:	701a      	strb	r2, [r3, #0]
			jumpToBoot();
 80142a6:	f000 f8d5 	bl	8014454 <jumpToBoot>
		Distance = ULTRASONIC_GetDistance();
 80142aa:	e79c      	b.n	80141e6 <main+0x1a6>
 80142ac:	08012800 	.word	0x08012800
 80142b0:	08004004 	.word	0x08004004
 80142b4:	e000ed00 	.word	0xe000ed00
 80142b8:	40011000 	.word	0x40011000
 80142bc:	40010800 	.word	0x40010800
 80142c0:	40006400 	.word	0x40006400
 80142c4:	40012c00 	.word	0x40012c00
 80142c8:	2000010c 	.word	0x2000010c
 80142cc:	20000130 	.word	0x20000130
 80142d0:	20000000 	.word	0x20000000
 80142d4:	20000131 	.word	0x20000131

080142d8 <CAN_SendData>:


}


void CAN_SendData(uint8_t* buffer, uint16_t length, uint32_t CAN_id){
 80142d8:	b580      	push	{r7, lr}
 80142da:	b08a      	sub	sp, #40	; 0x28
 80142dc:	af00      	add	r7, sp, #0
 80142de:	60f8      	str	r0, [r7, #12]
 80142e0:	460b      	mov	r3, r1
 80142e2:	607a      	str	r2, [r7, #4]
 80142e4:	817b      	strh	r3, [r7, #10]
	CAN_msg msg = {0};
 80142e6:	f107 0314 	add.w	r3, r7, #20
 80142ea:	2200      	movs	r2, #0
 80142ec:	601a      	str	r2, [r3, #0]
 80142ee:	605a      	str	r2, [r3, #4]
 80142f0:	609a      	str	r2, [r3, #8]
 80142f2:	60da      	str	r2, [r3, #12]
	msg.id = CAN_id;
 80142f4:	687b      	ldr	r3, [r7, #4]
 80142f6:	617b      	str	r3, [r7, #20]
	msg.format = STANDARD_FORMAT;
 80142f8:	2300      	movs	r3, #0
 80142fa:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
	msg.type = DATA_FRAME;
 80142fe:	2300      	movs	r3, #0
 8014300:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
	msg.length = length < 8 ? length : 8;
 8014304:	897b      	ldrh	r3, [r7, #10]
 8014306:	2b08      	cmp	r3, #8
 8014308:	bf28      	it	cs
 801430a:	2308      	movcs	r3, #8
 801430c:	b29b      	uxth	r3, r3
 801430e:	b2db      	uxtb	r3, r3
 8014310:	f887 3020 	strb.w	r3, [r7, #32]
	for (uint8_t datacounter = 0; datacounter < length;
 8014314:	2300      	movs	r3, #0
 8014316:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 801431a:	e038      	b.n	801438e <CAN_SendData+0xb6>
			datacounter += 8) {
		for (uint8_t msgcounter = 0; msgcounter < 8; msgcounter++) {
 801431c:	2300      	movs	r3, #0
 801431e:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 8014322:	e013      	b.n	801434c <CAN_SendData+0x74>
			msg.data[msgcounter] = buffer[datacounter
					+ msgcounter];
 8014324:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 8014328:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 801432c:	4413      	add	r3, r2
 801432e:	461a      	mov	r2, r3
			msg.data[msgcounter] = buffer[datacounter
 8014330:	68fb      	ldr	r3, [r7, #12]
 8014332:	441a      	add	r2, r3
 8014334:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8014338:	7812      	ldrb	r2, [r2, #0]
 801433a:	3328      	adds	r3, #40	; 0x28
 801433c:	443b      	add	r3, r7
 801433e:	f803 2c10 	strb.w	r2, [r3, #-16]
		for (uint8_t msgcounter = 0; msgcounter < 8; msgcounter++) {
 8014342:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8014346:	3301      	adds	r3, #1
 8014348:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
 801434c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 8014350:	2b07      	cmp	r3, #7
 8014352:	d9e7      	bls.n	8014324 <CAN_SendData+0x4c>
		}
		if((length - datacounter) >= 8){
 8014354:	897a      	ldrh	r2, [r7, #10]
 8014356:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801435a:	1ad3      	subs	r3, r2, r3
 801435c:	2b07      	cmp	r3, #7
 801435e:	dd03      	ble.n	8014368 <CAN_SendData+0x90>
			msg.length = 8;
 8014360:	2308      	movs	r3, #8
 8014362:	f887 3020 	strb.w	r3, [r7, #32]
 8014366:	e007      	b.n	8014378 <CAN_SendData+0xa0>
		}else{
			msg.length = length - datacounter;
 8014368:	897b      	ldrh	r3, [r7, #10]
 801436a:	b2da      	uxtb	r2, r3
 801436c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8014370:	1ad3      	subs	r3, r2, r3
 8014372:	b2db      	uxtb	r3, r3
 8014374:	f887 3020 	strb.w	r3, [r7, #32]
		}
		CAN_Transmit(CAN, &msg);
 8014378:	f107 0314 	add.w	r3, r7, #20
 801437c:	4619      	mov	r1, r3
 801437e:	4809      	ldr	r0, [pc, #36]	; (80143a4 <CAN_SendData+0xcc>)
 8014380:	f7fe ff87 	bl	8013292 <CAN_Transmit>
			datacounter += 8) {
 8014384:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8014388:	3308      	adds	r3, #8
 801438a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	for (uint8_t datacounter = 0; datacounter < length;
 801438e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8014392:	b29b      	uxth	r3, r3
 8014394:	897a      	ldrh	r2, [r7, #10]
 8014396:	429a      	cmp	r2, r3
 8014398:	d8c0      	bhi.n	801431c <CAN_SendData+0x44>
	}
}
 801439a:	bf00      	nop
 801439c:	bf00      	nop
 801439e:	3728      	adds	r7, #40	; 0x28
 80143a0:	46bd      	mov	sp, r7
 80143a2:	bd80      	pop	{r7, pc}
 80143a4:	40006400 	.word	0x40006400

080143a8 <System_DeInit>:




void System_DeInit(void);
void System_DeInit(void){
 80143a8:	b580      	push	{r7, lr}
 80143aa:	af00      	add	r7, sp, #0
	RCC->CFGR &= ~(RCC_CFGR_SW);
 80143ac:	4b1a      	ldr	r3, [pc, #104]	; (8014418 <System_DeInit+0x70>)
 80143ae:	685b      	ldr	r3, [r3, #4]
 80143b0:	4a19      	ldr	r2, [pc, #100]	; (8014418 <System_DeInit+0x70>)
 80143b2:	f023 0303 	bic.w	r3, r3, #3
 80143b6:	6053      	str	r3, [r2, #4]
	while((RCC->CFGR & RCC_CFGR_SWS) != 0);
 80143b8:	bf00      	nop
 80143ba:	4b17      	ldr	r3, [pc, #92]	; (8014418 <System_DeInit+0x70>)
 80143bc:	685b      	ldr	r3, [r3, #4]
 80143be:	f003 030c 	and.w	r3, r3, #12
 80143c2:	2b00      	cmp	r3, #0
 80143c4:	d1f9      	bne.n	80143ba <System_DeInit+0x12>
	RCC->CR &= ~(RCC_CR_PLLON);
 80143c6:	4b14      	ldr	r3, [pc, #80]	; (8014418 <System_DeInit+0x70>)
 80143c8:	681b      	ldr	r3, [r3, #0]
 80143ca:	4a13      	ldr	r2, [pc, #76]	; (8014418 <System_DeInit+0x70>)
 80143cc:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80143d0:	6013      	str	r3, [r2, #0]
	RCC->CR &= ~(RCC_CR_HSEON);
 80143d2:	4b11      	ldr	r3, [pc, #68]	; (8014418 <System_DeInit+0x70>)
 80143d4:	681b      	ldr	r3, [r3, #0]
 80143d6:	4a10      	ldr	r2, [pc, #64]	; (8014418 <System_DeInit+0x70>)
 80143d8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80143dc:	6013      	str	r3, [r2, #0]
	SysTick->CTRL = 0;
 80143de:	4b0f      	ldr	r3, [pc, #60]	; (801441c <System_DeInit+0x74>)
 80143e0:	2200      	movs	r2, #0
 80143e2:	601a      	str	r2, [r3, #0]
	SysTick->LOAD = 0;
 80143e4:	4b0d      	ldr	r3, [pc, #52]	; (801441c <System_DeInit+0x74>)
 80143e6:	2200      	movs	r2, #0
 80143e8:	605a      	str	r2, [r3, #4]
	SysTick->VAL = 0;
 80143ea:	4b0c      	ldr	r3, [pc, #48]	; (801441c <System_DeInit+0x74>)
 80143ec:	2200      	movs	r2, #0
 80143ee:	609a      	str	r2, [r3, #8]
	RCC_DisablePeripheral(RCC_AFIOCLK);
 80143f0:	2000      	movs	r0, #0
 80143f2:	f7ff fb63 	bl	8013abc <RCC_DisablePeripheral>
	RCC_DisablePeripheral(RCC_GPIOCCLK);
 80143f6:	2004      	movs	r0, #4
 80143f8:	f7ff fb60 	bl	8013abc <RCC_DisablePeripheral>
	RCC_DisablePeripheral(RCC_GPIOACLK);
 80143fc:	2002      	movs	r0, #2
 80143fe:	f7ff fb5d 	bl	8013abc <RCC_DisablePeripheral>
	RCC_DisablePeripheral(RCC_CANCLK);
 8014402:	2039      	movs	r0, #57	; 0x39
 8014404:	f7ff fb5a 	bl	8013abc <RCC_DisablePeripheral>
	RCC_DisablePeripheral(RCC_TIM1CLK);
 8014408:	200b      	movs	r0, #11
 801440a:	f7ff fb57 	bl	8013abc <RCC_DisablePeripheral>
	Disable_irq();
 801440e:	f7ff fa60 	bl	80138d2 <Disable_irq>
}
 8014412:	bf00      	nop
 8014414:	bd80      	pop	{r7, pc}
 8014416:	bf00      	nop
 8014418:	40021000 	.word	0x40021000
 801441c:	e000e010 	.word	0xe000e010

08014420 <JumpToApplication>:

void JumpToApplication( uint32_t appAddress);
void JumpToApplication( uint32_t appAddress){
 8014420:	b580      	push	{r7, lr}
 8014422:	b084      	sub	sp, #16
 8014424:	af00      	add	r7, sp, #0
 8014426:	6078      	str	r0, [r7, #4]
	void (*app_reset_handler)(void) = (void*)(*((volatile uint32_t*)(appAddress + 4U)));
 8014428:	687b      	ldr	r3, [r7, #4]
 801442a:	3304      	adds	r3, #4
 801442c:	681b      	ldr	r3, [r3, #0]
 801442e:	60fb      	str	r3, [r7, #12]
	SCB->VTOR = appAddress - FLASH_BASE;
 8014430:	4a07      	ldr	r2, [pc, #28]	; (8014450 <JumpToApplication+0x30>)
 8014432:	687b      	ldr	r3, [r7, #4]
 8014434:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
 8014438:	6093      	str	r3, [r2, #8]

	__asm volatile ("MSR msp, %0" : : "r" (*(volatile uint32_t*)appAddress) : );
 801443a:	687b      	ldr	r3, [r7, #4]
 801443c:	681b      	ldr	r3, [r3, #0]
 801443e:	f383 8808 	msr	MSP, r3

	app_reset_handler();
 8014442:	68fb      	ldr	r3, [r7, #12]
 8014444:	4798      	blx	r3
	//SCB_SystemReset();
}
 8014446:	bf00      	nop
 8014448:	3710      	adds	r7, #16
 801444a:	46bd      	mov	sp, r7
 801444c:	bd80      	pop	{r7, pc}
 801444e:	bf00      	nop
 8014450:	e000ed00 	.word	0xe000ed00

08014454 <jumpToBoot>:


void jumpToBoot(void){
 8014454:	b5b0      	push	{r4, r5, r7, lr}
 8014456:	af00      	add	r7, sp, #0
	//GPIO_Write_Pin(GPIOC, GPIO_PIN_13, HIGH);
	if(RX_msg.data[0] == 0x4){
 8014458:	4b0f      	ldr	r3, [pc, #60]	; (8014498 <jumpToBoot+0x44>)
 801445a:	791b      	ldrb	r3, [r3, #4]
 801445c:	2b04      	cmp	r3, #4
 801445e:	d018      	beq.n	8014492 <jumpToBoot+0x3e>
		return;
	}
	System_DeInit();
 8014460:	f7ff ffa2 	bl	80143a8 <System_DeInit>
	FLASH_Unlock();
 8014464:	f7ff f922 	bl	80136ac <FLASH_Unlock>
	FLASH_Program(FLASH_TYPEPROGRAM_WORD, BOOTLOADER_MODE_ADDRESS, BOOTLOADER_REQUEST | (RX_msg.data[0] << 8));
 8014468:	4b0b      	ldr	r3, [pc, #44]	; (8014498 <jumpToBoot+0x44>)
 801446a:	791b      	ldrb	r3, [r3, #4]
 801446c:	021b      	lsls	r3, r3, #8
 801446e:	f043 0301 	orr.w	r3, r3, #1
 8014472:	2200      	movs	r2, #0
 8014474:	461c      	mov	r4, r3
 8014476:	4615      	mov	r5, r2
 8014478:	4622      	mov	r2, r4
 801447a:	462b      	mov	r3, r5
 801447c:	4907      	ldr	r1, [pc, #28]	; (801449c <jumpToBoot+0x48>)
 801447e:	2002      	movs	r0, #2
 8014480:	f7ff f934 	bl	80136ec <FLASH_Program>
	FLASH_Lock();
 8014484:	f7ff f924 	bl	80136d0 <FLASH_Lock>
	JumpToApplication(FLASH_BASE);
 8014488:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 801448c:	f7ff ffc8 	bl	8014420 <JumpToApplication>
 8014490:	e000      	b.n	8014494 <jumpToBoot+0x40>
		return;
 8014492:	bf00      	nop
}
 8014494:	bdb0      	pop	{r4, r5, r7, pc}
 8014496:	bf00      	nop
 8014498:	20000110 	.word	0x20000110
 801449c:	08004000 	.word	0x08004000

080144a0 <USB_LP_CAN1_RX0_IRQHandler>:
		SysTick_Delay(1000);
		GPIO_Write_Pin(GPIOC, GPIO_PIN_13, LOW);
		SysTick_Delay(1000);*/

//fifo0
void USB_LP_CAN1_RX0_IRQHandler(void) {
 80144a0:	b580      	push	{r7, lr}
 80144a2:	af00      	add	r7, sp, #0

	if (CAN->RF0R & CAN_RF0R_FMP0) {
 80144a4:	4b37      	ldr	r3, [pc, #220]	; (8014584 <USB_LP_CAN1_RX0_IRQHandler+0xe4>)
 80144a6:	68db      	ldr	r3, [r3, #12]
 80144a8:	f003 0303 	and.w	r3, r3, #3
 80144ac:	2b00      	cmp	r3, #0
 80144ae:	d004      	beq.n	80144ba <USB_LP_CAN1_RX0_IRQHandler+0x1a>
		CAN_Receive(CAN, CAN_FIFO0, &RX_msg);
 80144b0:	4a35      	ldr	r2, [pc, #212]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 80144b2:	2100      	movs	r1, #0
 80144b4:	4833      	ldr	r0, [pc, #204]	; (8014584 <USB_LP_CAN1_RX0_IRQHandler+0xe4>)
 80144b6:	f7fe ffc4 	bl	8013442 <CAN_Receive>
	}
	if((RX_msg.id == CAN_CURRENTVERSION_ID) && (RX_msg.ActiveFlag == ENABLE)){
 80144ba:	4b33      	ldr	r3, [pc, #204]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 80144bc:	681b      	ldr	r3, [r3, #0]
 80144be:	2b07      	cmp	r3, #7
 80144c0:	d135      	bne.n	801452e <USB_LP_CAN1_RX0_IRQHandler+0x8e>
 80144c2:	4b31      	ldr	r3, [pc, #196]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 80144c4:	7bdb      	ldrb	r3, [r3, #15]
 80144c6:	2b01      	cmp	r3, #1
 80144c8:	d131      	bne.n	801452e <USB_LP_CAN1_RX0_IRQHandler+0x8e>
		GPIO_Write_Pin(GPIOA, GPIO_PIN_10, LOW);
 80144ca:	2200      	movs	r2, #0
 80144cc:	210a      	movs	r1, #10
 80144ce:	482f      	ldr	r0, [pc, #188]	; (801458c <USB_LP_CAN1_RX0_IRQHandler+0xec>)
 80144d0:	f7ff f9d1 	bl	8013876 <GPIO_Write_Pin>
		TX_msg.id = CAN_CURRENTVERSION_ID;
 80144d4:	4b2e      	ldr	r3, [pc, #184]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 80144d6:	2207      	movs	r2, #7
 80144d8:	601a      	str	r2, [r3, #0]
		TX_msg.format = STANDARD_FORMAT;
 80144da:	4b2d      	ldr	r3, [pc, #180]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 80144dc:	2200      	movs	r2, #0
 80144de:	735a      	strb	r2, [r3, #13]
		TX_msg.type = DATA_FRAME;
 80144e0:	4b2b      	ldr	r3, [pc, #172]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 80144e2:	2200      	movs	r2, #0
 80144e4:	739a      	strb	r2, [r3, #14]
		TX_msg.length = 2;
 80144e6:	4b2a      	ldr	r3, [pc, #168]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 80144e8:	2202      	movs	r2, #2
 80144ea:	731a      	strb	r2, [r3, #12]
		TX_msg.data[0] = 5;
 80144ec:	4b28      	ldr	r3, [pc, #160]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 80144ee:	2205      	movs	r2, #5
 80144f0:	711a      	strb	r2, [r3, #4]
		TX_msg.data[1] = 0;
 80144f2:	4b27      	ldr	r3, [pc, #156]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 80144f4:	2200      	movs	r2, #0
 80144f6:	715a      	strb	r2, [r3, #5]
		CAN_Transmit(CAN, &TX_msg);
 80144f8:	4925      	ldr	r1, [pc, #148]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 80144fa:	4822      	ldr	r0, [pc, #136]	; (8014584 <USB_LP_CAN1_RX0_IRQHandler+0xe4>)
 80144fc:	f7fe fec9 	bl	8013292 <CAN_Transmit>
		TX_msg.length = 5;
 8014500:	4b23      	ldr	r3, [pc, #140]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 8014502:	2205      	movs	r2, #5
 8014504:	731a      	strb	r2, [r3, #12]
		TX_msg.data[0] = currentVersion[0];
 8014506:	2232      	movs	r2, #50	; 0x32
 8014508:	4b21      	ldr	r3, [pc, #132]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 801450a:	711a      	strb	r2, [r3, #4]
		TX_msg.data[1] = currentVersion[1];
 801450c:	222e      	movs	r2, #46	; 0x2e
 801450e:	4b20      	ldr	r3, [pc, #128]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 8014510:	715a      	strb	r2, [r3, #5]
		TX_msg.data[2] = currentVersion[2];
 8014512:	2230      	movs	r2, #48	; 0x30
 8014514:	4b1e      	ldr	r3, [pc, #120]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 8014516:	719a      	strb	r2, [r3, #6]
		TX_msg.data[3] = currentVersion[3];
 8014518:	222e      	movs	r2, #46	; 0x2e
 801451a:	4b1d      	ldr	r3, [pc, #116]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 801451c:	71da      	strb	r2, [r3, #7]
		TX_msg.data[4] = currentVersion[4];
 801451e:	2230      	movs	r2, #48	; 0x30
 8014520:	4b1b      	ldr	r3, [pc, #108]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 8014522:	721a      	strb	r2, [r3, #8]
		CAN_Transmit(CAN, &TX_msg);
 8014524:	491a      	ldr	r1, [pc, #104]	; (8014590 <USB_LP_CAN1_RX0_IRQHandler+0xf0>)
 8014526:	4817      	ldr	r0, [pc, #92]	; (8014584 <USB_LP_CAN1_RX0_IRQHandler+0xe4>)
 8014528:	f7fe feb3 	bl	8013292 <CAN_Transmit>
 801452c:	e027      	b.n	801457e <USB_LP_CAN1_RX0_IRQHandler+0xde>

	}else if ((RX_msg.id == CAN_BOOTLOADER_RQ_ID) && (RX_msg.ActiveFlag == ENABLE)) {
 801452e:	4b16      	ldr	r3, [pc, #88]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 8014530:	681b      	ldr	r3, [r3, #0]
 8014532:	f240 1223 	movw	r2, #291	; 0x123
 8014536:	4293      	cmp	r3, r2
 8014538:	d107      	bne.n	801454a <USB_LP_CAN1_RX0_IRQHandler+0xaa>
 801453a:	4b13      	ldr	r3, [pc, #76]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 801453c:	7bdb      	ldrb	r3, [r3, #15]
 801453e:	2b01      	cmp	r3, #1
 8014540:	d103      	bne.n	801454a <USB_LP_CAN1_RX0_IRQHandler+0xaa>
		isBootloaderRQ = 1;
 8014542:	4b14      	ldr	r3, [pc, #80]	; (8014594 <USB_LP_CAN1_RX0_IRQHandler+0xf4>)
 8014544:	2201      	movs	r2, #1
 8014546:	701a      	strb	r2, [r3, #0]
 8014548:	e019      	b.n	801457e <USB_LP_CAN1_RX0_IRQHandler+0xde>

	}else if ((RX_msg.id == ECU_DIAGNOSTIC_LOG_ID) && (ecu_id == (RX_msg.data[0] | RX_msg.data[1] << 8)) && (RX_msg.ActiveFlag == ENABLE)){
 801454a:	4b0f      	ldr	r3, [pc, #60]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 801454c:	681b      	ldr	r3, [r3, #0]
 801454e:	2b16      	cmp	r3, #22
 8014550:	d115      	bne.n	801457e <USB_LP_CAN1_RX0_IRQHandler+0xde>
 8014552:	2301      	movs	r3, #1
 8014554:	461a      	mov	r2, r3
 8014556:	4b0c      	ldr	r3, [pc, #48]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 8014558:	791b      	ldrb	r3, [r3, #4]
 801455a:	4619      	mov	r1, r3
 801455c:	4b0a      	ldr	r3, [pc, #40]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 801455e:	795b      	ldrb	r3, [r3, #5]
 8014560:	021b      	lsls	r3, r3, #8
 8014562:	430b      	orrs	r3, r1
 8014564:	429a      	cmp	r2, r3
 8014566:	d10a      	bne.n	801457e <USB_LP_CAN1_RX0_IRQHandler+0xde>
 8014568:	4b07      	ldr	r3, [pc, #28]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 801456a:	7bdb      	ldrb	r3, [r3, #15]
 801456c:	2b01      	cmp	r3, #1
 801456e:	d106      	bne.n	801457e <USB_LP_CAN1_RX0_IRQHandler+0xde>
		isdiagRequest = 1;
 8014570:	4b09      	ldr	r3, [pc, #36]	; (8014598 <USB_LP_CAN1_RX0_IRQHandler+0xf8>)
 8014572:	2201      	movs	r2, #1
 8014574:	701a      	strb	r2, [r3, #0]
		RX_msg.ActiveFlag = DISABLE;
 8014576:	4b04      	ldr	r3, [pc, #16]	; (8014588 <USB_LP_CAN1_RX0_IRQHandler+0xe8>)
 8014578:	2200      	movs	r2, #0
 801457a:	73da      	strb	r2, [r3, #15]
	}

}
 801457c:	e7ff      	b.n	801457e <USB_LP_CAN1_RX0_IRQHandler+0xde>
 801457e:	bf00      	nop
 8014580:	bd80      	pop	{r7, pc}
 8014582:	bf00      	nop
 8014584:	40006400 	.word	0x40006400
 8014588:	20000110 	.word	0x20000110
 801458c:	40010800 	.word	0x40010800
 8014590:	20000120 	.word	0x20000120
 8014594:	20000131 	.word	0x20000131
 8014598:	20000130 	.word	0x20000130

0801459c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 801459c:	b480      	push	{r7}
 801459e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80145a0:	e7fe      	b.n	80145a0 <NMI_Handler+0x4>

080145a2 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80145a2:	b480      	push	{r7}
 80145a4:	b083      	sub	sp, #12
 80145a6:	af00      	add	r7, sp, #0
	/* USER CODE BEGIN MemoryManagement_IRQn 0 */
		uint8_t cont = 0;
 80145a8:	2300      	movs	r3, #0
 80145aa:	71fb      	strb	r3, [r7, #7]
	  /* USER CODE END MemoryManagement_IRQn 0 */
	  while (cont == 0)
 80145ac:	79fb      	ldrb	r3, [r7, #7]
 80145ae:	2b00      	cmp	r3, #0
 80145b0:	d0fc      	beq.n	80145ac <HardFault_Handler+0xa>
	  {
	    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
	    /* USER CODE END W1_MemoryManagement_IRQn 0 */
	  }
}
 80145b2:	bf00      	nop
 80145b4:	bf00      	nop
 80145b6:	370c      	adds	r7, #12
 80145b8:	46bd      	mov	sp, r7
 80145ba:	bc80      	pop	{r7}
 80145bc:	4770      	bx	lr

080145be <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80145be:	b480      	push	{r7}
 80145c0:	b083      	sub	sp, #12
 80145c2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */
	uint8_t cont = 0;
 80145c4:	2300      	movs	r3, #0
 80145c6:	71fb      	strb	r3, [r7, #7]
  /* USER CODE END MemoryManagement_IRQn 0 */
  while (cont == 0)
 80145c8:	79fb      	ldrb	r3, [r7, #7]
 80145ca:	2b00      	cmp	r3, #0
 80145cc:	d0fc      	beq.n	80145c8 <MemManage_Handler+0xa>
  {
    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    /* USER CODE END W1_MemoryManagement_IRQn 0 */
  }
}
 80145ce:	bf00      	nop
 80145d0:	bf00      	nop
 80145d2:	370c      	adds	r7, #12
 80145d4:	46bd      	mov	sp, r7
 80145d6:	bc80      	pop	{r7}
 80145d8:	4770      	bx	lr

080145da <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80145da:	b480      	push	{r7}
 80145dc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80145de:	e7fe      	b.n	80145de <BusFault_Handler+0x4>

080145e0 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80145e0:	b480      	push	{r7}
 80145e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80145e4:	e7fe      	b.n	80145e4 <UsageFault_Handler+0x4>

080145e6 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80145e6:	b480      	push	{r7}
 80145e8:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80145ea:	bf00      	nop
 80145ec:	46bd      	mov	sp, r7
 80145ee:	bc80      	pop	{r7}
 80145f0:	4770      	bx	lr

080145f2 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80145f2:	b480      	push	{r7}
 80145f4:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 80145f6:	bf00      	nop
 80145f8:	46bd      	mov	sp, r7
 80145fa:	bc80      	pop	{r7}
 80145fc:	4770      	bx	lr

080145fe <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80145fe:	b480      	push	{r7}
 8014600:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8014602:	bf00      	nop
 8014604:	46bd      	mov	sp, r7
 8014606:	bc80      	pop	{r7}
 8014608:	4770      	bx	lr
	...

0801460c <SysTick_Handler>:
/**
  * @brief This function handles System tick timer.
  */
extern volatile uint32_t ticks;
void SysTick_Handler(void)
{
 801460c:	b480      	push	{r7}
 801460e:	af00      	add	r7, sp, #0
	ticks++;
 8014610:	4b04      	ldr	r3, [pc, #16]	; (8014624 <SysTick_Handler+0x18>)
 8014612:	681b      	ldr	r3, [r3, #0]
 8014614:	3301      	adds	r3, #1
 8014616:	4a03      	ldr	r2, [pc, #12]	; (8014624 <SysTick_Handler+0x18>)
 8014618:	6013      	str	r3, [r2, #0]

}
 801461a:	bf00      	nop
 801461c:	46bd      	mov	sp, r7
 801461e:	bc80      	pop	{r7}
 8014620:	4770      	bx	lr
 8014622:	bf00      	nop
 8014624:	20000108 	.word	0x20000108

08014628 <EXTI0_IRQHandler>:
/* please refer to the startup file (startup_stm32f1xx.s).                    */
/******************************************************************************/

/* USER CODE BEGIN 1 */
//EXTI
void EXTI0_IRQHandler(void){
 8014628:	b480      	push	{r7}
 801462a:	af00      	add	r7, sp, #0

}
 801462c:	bf00      	nop
 801462e:	46bd      	mov	sp, r7
 8014630:	bc80      	pop	{r7}
 8014632:	4770      	bx	lr

08014634 <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void){
 8014634:	b480      	push	{r7}
 8014636:	af00      	add	r7, sp, #0


}
 8014638:	bf00      	nop
 801463a:	46bd      	mov	sp, r7
 801463c:	bc80      	pop	{r7}
 801463e:	4770      	bx	lr

08014640 <EXTI2_IRQHandler>:
void EXTI2_IRQHandler(void){
 8014640:	b480      	push	{r7}
 8014642:	af00      	add	r7, sp, #0

}
 8014644:	bf00      	nop
 8014646:	46bd      	mov	sp, r7
 8014648:	bc80      	pop	{r7}
 801464a:	4770      	bx	lr

0801464c <EXTI3_IRQHandler>:
void EXTI3_IRQHandler(void){
 801464c:	b480      	push	{r7}
 801464e:	af00      	add	r7, sp, #0

}
 8014650:	bf00      	nop
 8014652:	46bd      	mov	sp, r7
 8014654:	bc80      	pop	{r7}
 8014656:	4770      	bx	lr

08014658 <EXTI4_IRQHandler>:
void EXTI4_IRQHandler(void){
 8014658:	b480      	push	{r7}
 801465a:	af00      	add	r7, sp, #0

}
 801465c:	bf00      	nop
 801465e:	46bd      	mov	sp, r7
 8014660:	bc80      	pop	{r7}
 8014662:	4770      	bx	lr

08014664 <DMA1_Channel1_IRQHandler>:
//DMA
extern fptr DMA_fptr[7];
void DMA1_Channel1_IRQHandler(void){
 8014664:	b580      	push	{r7, lr}
 8014666:	af00      	add	r7, sp, #0

	if(DMA->ISR & DMA_ISR_TCIF1){
 8014668:	4b09      	ldr	r3, [pc, #36]	; (8014690 <DMA1_Channel1_IRQHandler+0x2c>)
 801466a:	681b      	ldr	r3, [r3, #0]
 801466c:	f003 0302 	and.w	r3, r3, #2
 8014670:	2b00      	cmp	r3, #0
 8014672:	d002      	beq.n	801467a <DMA1_Channel1_IRQHandler+0x16>
		DMA_fptr[0]();
 8014674:	4b07      	ldr	r3, [pc, #28]	; (8014694 <DMA1_Channel1_IRQHandler+0x30>)
 8014676:	681b      	ldr	r3, [r3, #0]
 8014678:	4798      	blx	r3
	}
	DMA->IFCR |= (DMA_IFCR_CTCIF1);
 801467a:	4b05      	ldr	r3, [pc, #20]	; (8014690 <DMA1_Channel1_IRQHandler+0x2c>)
 801467c:	685b      	ldr	r3, [r3, #4]
 801467e:	4a04      	ldr	r2, [pc, #16]	; (8014690 <DMA1_Channel1_IRQHandler+0x2c>)
 8014680:	f043 0302 	orr.w	r3, r3, #2
 8014684:	6053      	str	r3, [r2, #4]
	NVIC_ClearPendingIRQ(DMA1_Channel1_IRQn);
 8014686:	200b      	movs	r0, #11
 8014688:	f7ff f944 	bl	8013914 <NVIC_ClearPendingIRQ>
}
 801468c:	bf00      	nop
 801468e:	bd80      	pop	{r7, pc}
 8014690:	40020000 	.word	0x40020000
 8014694:	200000ec 	.word	0x200000ec

08014698 <DMA1_Channel2_IRQHandler>:
void DMA1_Channel2_IRQHandler(void){
 8014698:	b580      	push	{r7, lr}
 801469a:	af00      	add	r7, sp, #0
	if(DMA->ISR & DMA_ISR_TCIF2){
 801469c:	4b09      	ldr	r3, [pc, #36]	; (80146c4 <DMA1_Channel2_IRQHandler+0x2c>)
 801469e:	681b      	ldr	r3, [r3, #0]
 80146a0:	f003 0320 	and.w	r3, r3, #32
 80146a4:	2b00      	cmp	r3, #0
 80146a6:	d002      	beq.n	80146ae <DMA1_Channel2_IRQHandler+0x16>
			DMA_fptr[1]();
 80146a8:	4b07      	ldr	r3, [pc, #28]	; (80146c8 <DMA1_Channel2_IRQHandler+0x30>)
 80146aa:	685b      	ldr	r3, [r3, #4]
 80146ac:	4798      	blx	r3
		}
	DMA->IFCR |= (DMA_IFCR_CTCIF2);
 80146ae:	4b05      	ldr	r3, [pc, #20]	; (80146c4 <DMA1_Channel2_IRQHandler+0x2c>)
 80146b0:	685b      	ldr	r3, [r3, #4]
 80146b2:	4a04      	ldr	r2, [pc, #16]	; (80146c4 <DMA1_Channel2_IRQHandler+0x2c>)
 80146b4:	f043 0320 	orr.w	r3, r3, #32
 80146b8:	6053      	str	r3, [r2, #4]
		NVIC_ClearPendingIRQ(DMA1_Channel2_IRQn);
 80146ba:	200c      	movs	r0, #12
 80146bc:	f7ff f92a 	bl	8013914 <NVIC_ClearPendingIRQ>
}
 80146c0:	bf00      	nop
 80146c2:	bd80      	pop	{r7, pc}
 80146c4:	40020000 	.word	0x40020000
 80146c8:	200000ec 	.word	0x200000ec

080146cc <DMA1_Channel3_IRQHandler>:
void DMA1_Channel3_IRQHandler(void){
 80146cc:	b580      	push	{r7, lr}
 80146ce:	af00      	add	r7, sp, #0
	if(DMA->ISR & DMA_ISR_TCIF3){
 80146d0:	4b09      	ldr	r3, [pc, #36]	; (80146f8 <DMA1_Channel3_IRQHandler+0x2c>)
 80146d2:	681b      	ldr	r3, [r3, #0]
 80146d4:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80146d8:	2b00      	cmp	r3, #0
 80146da:	d002      	beq.n	80146e2 <DMA1_Channel3_IRQHandler+0x16>
			DMA_fptr[2]();
 80146dc:	4b07      	ldr	r3, [pc, #28]	; (80146fc <DMA1_Channel3_IRQHandler+0x30>)
 80146de:	689b      	ldr	r3, [r3, #8]
 80146e0:	4798      	blx	r3
		}
	DMA->IFCR |= (DMA_IFCR_CTCIF3);
 80146e2:	4b05      	ldr	r3, [pc, #20]	; (80146f8 <DMA1_Channel3_IRQHandler+0x2c>)
 80146e4:	685b      	ldr	r3, [r3, #4]
 80146e6:	4a04      	ldr	r2, [pc, #16]	; (80146f8 <DMA1_Channel3_IRQHandler+0x2c>)
 80146e8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80146ec:	6053      	str	r3, [r2, #4]
		NVIC_ClearPendingIRQ(DMA1_Channel3_IRQn);
 80146ee:	200d      	movs	r0, #13
 80146f0:	f7ff f910 	bl	8013914 <NVIC_ClearPendingIRQ>
}
 80146f4:	bf00      	nop
 80146f6:	bd80      	pop	{r7, pc}
 80146f8:	40020000 	.word	0x40020000
 80146fc:	200000ec 	.word	0x200000ec

08014700 <DMA1_Channel4_IRQHandler>:
void DMA1_Channel4_IRQHandler(void){
 8014700:	b580      	push	{r7, lr}
 8014702:	af00      	add	r7, sp, #0
	if(DMA->ISR & DMA_ISR_TCIF4){
 8014704:	4b09      	ldr	r3, [pc, #36]	; (801472c <DMA1_Channel4_IRQHandler+0x2c>)
 8014706:	681b      	ldr	r3, [r3, #0]
 8014708:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801470c:	2b00      	cmp	r3, #0
 801470e:	d002      	beq.n	8014716 <DMA1_Channel4_IRQHandler+0x16>
			DMA_fptr[3]();
 8014710:	4b07      	ldr	r3, [pc, #28]	; (8014730 <DMA1_Channel4_IRQHandler+0x30>)
 8014712:	68db      	ldr	r3, [r3, #12]
 8014714:	4798      	blx	r3
		}
	DMA->IFCR |= (DMA_IFCR_CTCIF4);
 8014716:	4b05      	ldr	r3, [pc, #20]	; (801472c <DMA1_Channel4_IRQHandler+0x2c>)
 8014718:	685b      	ldr	r3, [r3, #4]
 801471a:	4a04      	ldr	r2, [pc, #16]	; (801472c <DMA1_Channel4_IRQHandler+0x2c>)
 801471c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8014720:	6053      	str	r3, [r2, #4]
		NVIC_ClearPendingIRQ(DMA1_Channel4_IRQn);
 8014722:	200e      	movs	r0, #14
 8014724:	f7ff f8f6 	bl	8013914 <NVIC_ClearPendingIRQ>
}
 8014728:	bf00      	nop
 801472a:	bd80      	pop	{r7, pc}
 801472c:	40020000 	.word	0x40020000
 8014730:	200000ec 	.word	0x200000ec

08014734 <DMA1_Channel5_IRQHandler>:
void DMA1_Channel5_IRQHandler(void){
 8014734:	b580      	push	{r7, lr}
 8014736:	af00      	add	r7, sp, #0
	if(DMA->ISR & DMA_ISR_TCIF5){
 8014738:	4b09      	ldr	r3, [pc, #36]	; (8014760 <DMA1_Channel5_IRQHandler+0x2c>)
 801473a:	681b      	ldr	r3, [r3, #0]
 801473c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8014740:	2b00      	cmp	r3, #0
 8014742:	d002      	beq.n	801474a <DMA1_Channel5_IRQHandler+0x16>
			DMA_fptr[4]();
 8014744:	4b07      	ldr	r3, [pc, #28]	; (8014764 <DMA1_Channel5_IRQHandler+0x30>)
 8014746:	691b      	ldr	r3, [r3, #16]
 8014748:	4798      	blx	r3
		}
	DMA->IFCR |= (DMA_IFCR_CTCIF5);
 801474a:	4b05      	ldr	r3, [pc, #20]	; (8014760 <DMA1_Channel5_IRQHandler+0x2c>)
 801474c:	685b      	ldr	r3, [r3, #4]
 801474e:	4a04      	ldr	r2, [pc, #16]	; (8014760 <DMA1_Channel5_IRQHandler+0x2c>)
 8014750:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8014754:	6053      	str	r3, [r2, #4]
		NVIC_ClearPendingIRQ(DMA1_Channel5_IRQn);
 8014756:	200f      	movs	r0, #15
 8014758:	f7ff f8dc 	bl	8013914 <NVIC_ClearPendingIRQ>
}
 801475c:	bf00      	nop
 801475e:	bd80      	pop	{r7, pc}
 8014760:	40020000 	.word	0x40020000
 8014764:	200000ec 	.word	0x200000ec

08014768 <DMA1_Channel6_IRQHandler>:
void DMA1_Channel6_IRQHandler(void){
 8014768:	b580      	push	{r7, lr}
 801476a:	af00      	add	r7, sp, #0
	if(DMA->ISR & DMA_ISR_TCIF6){
 801476c:	4b09      	ldr	r3, [pc, #36]	; (8014794 <DMA1_Channel6_IRQHandler+0x2c>)
 801476e:	681b      	ldr	r3, [r3, #0]
 8014770:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8014774:	2b00      	cmp	r3, #0
 8014776:	d002      	beq.n	801477e <DMA1_Channel6_IRQHandler+0x16>
			DMA_fptr[5]();
 8014778:	4b07      	ldr	r3, [pc, #28]	; (8014798 <DMA1_Channel6_IRQHandler+0x30>)
 801477a:	695b      	ldr	r3, [r3, #20]
 801477c:	4798      	blx	r3
		}
	DMA->IFCR |= (DMA_IFCR_CTCIF6);
 801477e:	4b05      	ldr	r3, [pc, #20]	; (8014794 <DMA1_Channel6_IRQHandler+0x2c>)
 8014780:	685b      	ldr	r3, [r3, #4]
 8014782:	4a04      	ldr	r2, [pc, #16]	; (8014794 <DMA1_Channel6_IRQHandler+0x2c>)
 8014784:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8014788:	6053      	str	r3, [r2, #4]
		NVIC_ClearPendingIRQ(DMA1_Channel6_IRQn);
 801478a:	2010      	movs	r0, #16
 801478c:	f7ff f8c2 	bl	8013914 <NVIC_ClearPendingIRQ>
}
 8014790:	bf00      	nop
 8014792:	bd80      	pop	{r7, pc}
 8014794:	40020000 	.word	0x40020000
 8014798:	200000ec 	.word	0x200000ec

0801479c <DMA1_Channel7_IRQHandler>:
void DMA1_Channel7_IRQHandler(void){
 801479c:	b580      	push	{r7, lr}
 801479e:	af00      	add	r7, sp, #0
	if(DMA->ISR & DMA_ISR_TCIF7){
 80147a0:	4b09      	ldr	r3, [pc, #36]	; (80147c8 <DMA1_Channel7_IRQHandler+0x2c>)
 80147a2:	681b      	ldr	r3, [r3, #0]
 80147a4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80147a8:	2b00      	cmp	r3, #0
 80147aa:	d002      	beq.n	80147b2 <DMA1_Channel7_IRQHandler+0x16>
			DMA_fptr[6]();
 80147ac:	4b07      	ldr	r3, [pc, #28]	; (80147cc <DMA1_Channel7_IRQHandler+0x30>)
 80147ae:	699b      	ldr	r3, [r3, #24]
 80147b0:	4798      	blx	r3
		}
	DMA->IFCR |= (DMA_IFCR_CTCIF7);
 80147b2:	4b05      	ldr	r3, [pc, #20]	; (80147c8 <DMA1_Channel7_IRQHandler+0x2c>)
 80147b4:	685b      	ldr	r3, [r3, #4]
 80147b6:	4a04      	ldr	r2, [pc, #16]	; (80147c8 <DMA1_Channel7_IRQHandler+0x2c>)
 80147b8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80147bc:	6053      	str	r3, [r2, #4]
		NVIC_ClearPendingIRQ(DMA1_Channel7_IRQn);
 80147be:	2011      	movs	r0, #17
 80147c0:	f7ff f8a8 	bl	8013914 <NVIC_ClearPendingIRQ>
}
 80147c4:	bf00      	nop
 80147c6:	bd80      	pop	{r7, pc}
 80147c8:	40020000 	.word	0x40020000
 80147cc:	200000ec 	.word	0x200000ec

080147d0 <Reset_Handler>:
Reset_Handler:



/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80147d0:	480a      	ldr	r0, [pc, #40]	; (80147fc <LoopFillZerobss+0xa>)
  ldr r1, =_edata
 80147d2:	490b      	ldr	r1, [pc, #44]	; (8014800 <LoopFillZerobss+0xe>)
  ldr r2, =_sidata
 80147d4:	4a0b      	ldr	r2, [pc, #44]	; (8014804 <LoopFillZerobss+0x12>)
  movs r3, #0
 80147d6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80147d8:	e002      	b.n	80147e0 <LoopCopyDataInit>

080147da <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80147da:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80147dc:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80147de:	3304      	adds	r3, #4

080147e0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80147e0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80147e2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80147e4:	d3f9      	bcc.n	80147da <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80147e6:	4a08      	ldr	r2, [pc, #32]	; (8014808 <LoopFillZerobss+0x16>)
  ldr r4, =_ebss
 80147e8:	4c08      	ldr	r4, [pc, #32]	; (801480c <LoopFillZerobss+0x1a>)
  movs r3, #0
 80147ea:	2300      	movs	r3, #0
  b LoopFillZerobss
 80147ec:	e001      	b.n	80147f2 <LoopFillZerobss>

080147ee <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80147ee:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80147f0:	3204      	adds	r2, #4

080147f2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80147f2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80147f4:	d3fb      	bcc.n	80147ee <FillZerobss>


/* Call the application's entry point.*/
  bl main
 80147f6:	f7ff fc23 	bl	8014040 <main>
  bx lr
 80147fa:	4770      	bx	lr
  ldr r0, =_sdata
 80147fc:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8014800:	200000d0 	.word	0x200000d0
  ldr r2, =_sidata
 8014804:	08014834 	.word	0x08014834
  ldr r2, =_sbss
 8014808:	200000d0 	.word	0x200000d0
  ldr r4, =_ebss
 801480c:	20000134 	.word	0x20000134

08014810 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8014810:	e7fe      	b.n	8014810 <ADC1_2_IRQHandler>
	...

08014814 <_init>:
 8014814:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014816:	bf00      	nop
 8014818:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801481a:	bc08      	pop	{r3}
 801481c:	469e      	mov	lr, r3
 801481e:	4770      	bx	lr

08014820 <_fini>:
 8014820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014822:	bf00      	nop
 8014824:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014826:	bc08      	pop	{r3}
 8014828:	469e      	mov	lr, r3
 801482a:	4770      	bx	lr
